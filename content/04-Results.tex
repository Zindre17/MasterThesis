\section{Results}
This section will present the results, in regards to development and testing. The part about development will touch upon architecture or structure, some specifics of major components, and some bugs and stumbles which are worth mentioning. The testing part will present test results without any interpretation, just numbers. The interpretation of the test results will come in the next section: Discussion. 

\subsection{Architecture}
%these figures should be in the method chapter somewhere
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/actual_result.png}
\caption{The conclusive plan for how the scenes in the game would be arranged}
\label{fig:plan_final}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/Plan.png}
\caption{The conclusive plan for how the scenes in the game would be arranged}
\label{fig:plan}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/potential_further_dev.png}
\caption{The conclusive plan for how the scenes in the game would be arranged}
\label{fig:plan_potential}
\end{figure}

\subsection{Some Components}
This sub chapter will describe some of the most important pieces of this software and how they work. Not in too much detail though. For more details the code can be found on \href{https://github.com/Zindre17/UniVRsity}{Github}, but beware the code is practically only self commented. And not even that well self commented. I felt no need to comment the code, as I was constantly revisiting old code and doing improvements, and knew it pretty much inside out without the commenting. There were occasions where some comments could have saved me some time during some refactors though. 
The different pieces will be classified as either one of these: 
\begin{itemize}
    \item A component - A C\# class inheriting from MonoBehaviour.
    \item A prefab - A template for a game object which can be used to spawn predefined game objects at run-time or for speeding up the scene building process.
    \item A class - A C\# class
    \item An interface - A C\# interface
\end{itemize}

\subsubsection{LaserPointerPlayer} \label{subsubsec:LPP} 
The LaserPointerPlayer prefab was a modified version of the Player prefab which is shipped out of the box with Steam VR. The Player prefab controls the tracking of the controllers and the HMD. The modified version removed the hand models, and their gesture simulation as this is not needed for the interaction within the game. Instead the hand models were replaced by spheres and attached to the right hand was a laser pointer which is used for interaction. Along with this laser pointer model, a component/script was add to control this model. 

\subsubsection{\_FallbackGame}
\_FallbackGame is a prefab, and it came to be after a bug found late in the development. Shortly explained, the \hyperref[subsubsec:LPP]{LaserPointerPrefab} prefab object would not be destroyed when changing scenes and there would be multiple of these when more than one scene was used. More on this in the next section. The purpos of this \_FallbackGame object was to check for a player and if there was none, instantiate one, else, destroy itself. This made it possible to start the game from any scene and still visit other scenes without getting multiple players, and without only having a player in one of the scenes. And since there would only every be one of these objects, the opportunity arose to move all other components which were required by all scenes into this same object. These are the EventManager and the ColorManager. 

%In the prototype the sorting algorithms are based around a "SortManager", an "EventManager", the "SortingElement", the "ISortingAlgorithm", and the "GameAction". 
\subsubsection{SortingManger}
The SortingManager is a component which basically glues everything together and keeps track handles most of the logic for the flow of the game. Basically the big boss commanding all its minions. This class is however dependent on a lot of other smaller components. This class does not know \textit{how} to do things, only \textit{what} to do. Therefore it must have references to the components which actually know \textit{how} to perform these actions or handle specific events. It does not only know \textit{what} to do, it also knows \textit{when this is allowed} to do. In other words, it keeps track of a bunch of states and when it is notified of some interaction happening, it will decide whether or not this is legal and act accordingly. 
Some references it keeps are :
\begin{itemize}
    \item \hyperref[subsubsec:SortingAlgorithm]{SortingAlgorithm} - An algorithm which the array should be sorted after
    \item \hyperref[subsubsec:Arrays]{Arrays} - Keeps track of all the arrays, and the logic for interacting with them
    \item Comparison - Handles compare actions
    \item TitleManager - Updates the title of the room to the current algorithm
    \item StateManager - Shows the updated state of the algorithms internals
    \item ActionManager - Handles the state of the Action buttons (active or not)
    \item AlgoControlManager - Handles the state of the buttons controlling the algorithm(Demo, prev, and next)
    \item MessagesManager - Shows messages to the player about things that are happening
\end{itemize}

%this needs a rewrite 
\subsubsection{Arrays and ElementAnimator} \label{subsubsec:Arrays}
"Arrays" and "ElementAnimator" are components used in the sorting algorithms scene. They handle the logic of how the different actions affect the array(s) and their respectful animation definitions, and last but not least which array it should perform the action on. In the beginning they were the same component, but it got really big and I wanted to separate the Animations of the different actions with the logic behind them. And hence they became two. However, it turned out some of the logic still had to happen within the animation and are therefore not completely separate after all... Nevertheless, it turned out to be helpful in terms of navigating the code, when all the animation logic was in one file, while most of the logic was in the other.

The "Arrays" component is also an evolution from "ArrayManager". As I added the merge sort algorithm there was need for more than one array, and therefore the ArrayManager which was doing everything for the original array was not sufficient any more. Hence the "Array" component was created. It stole the logic from "ArrayManager" and added some more to handle several arrays. The Arraymanager was cut down to only keep track of its elements. 
So the history went like this:
\begin{itemize}
    \item ArrayManager
    \item ArrayManager and Arrays
    \item ArrayManager, Arrays and ElementAnimator
\end{itemize}

\subsubsection{EventManager}
The EventManager is a class which contains every event which could happen in the game, and allows other classes or components to subscribe to these events. The events are set up with delegate types for the different types of events, and matching static events using these delegate types. making the events static means that other components does not need a reference to the active EventManager in order to subscribe to events. Then, all a component need to do in order to subscribe to an event is to define a function which takes the same parameters as the delegate type of the event, and append that function to the event. Like this: 
\begin{lstlisting}[language=C]
// Subscribe to event
EventManager.Name_of_event += Name_of_function;

// Unsubscribe from event
EventManager.Name_of_event -= Name_of_function;
\end{lstlisting} 

This component also has the responsibility to handle the laser pointer and the interaction with the controllers. It has a reference to the LaserPointer, a component attached to the \hyperref[subsubsec:LPP]{LaserPointerPlayer} object, which gives the EventManager information about the position and orientation of the pointer. Every frame it then uses this information to fire a ray cast from the tip of the laser pointer in the direction it faces. After that it uses the result of the ray cast in order to check whether it is pointing at an interactive object. If it is pointing at an interactive object, it will trigger the hover effect of that object, and if the player is also pressing the trigger button while pointing at this interactive object, it will fire the appropriate event according to the type of interactive object. 

\subsubsection{SortingAlgorithm} \label{subsubsec:SortingAlgorithm}
SortingAlgorithm is an abstract class, and defines a set of abstract methods which all sub-classes needs to implement and a set of virtual methods which already has a definition but can be overridden by the sub-classes. Having this abstract class makes adding new algorithms a lot faster, as a lot of the code for each algorithm would be the same. It also makes the addition of new algorithms less error prone, as the core is already there for each algorithm and only what is specific for the algorithm needs to be added. The abstract methods are the GenerateActions method, and the CheckForFocusChange method. GenerateActions return Void and takes no parameters. It is called in the constructor and the intention of this method is to add all the GameActions needed to sort the array in the correct order and with the correct indexes to the actions list, as well as add an equal number of states to the states list to let the user peek inside the state of the algorithm. The CheckForFocusChange method should send trigger an event in the EventManager when the algorithm reaches a state where there is a change in which elements are in focus.

\subsubsection{GameAction}
GameAction is an abstract class which all actions that a user can perform inherits from. This class contains very little functionality as its reason for existing was to be able to group several different actions under the same type, such that collections could be made. By inheriting from this class one can also quite easily add new actions as well, though they also have to be defined in the SortManager, as these classes are only a representation of an action, and not the action itself. The functionality of the action is decided by the SortManager. In this way, the same action can be handled diffrently in another context, for example for tree traversal algorithms. 


\subsection{Bugs and stumbles}
% the problem of VR player not beeing deleted between scenes, and the solution to that
Improper use of the player prefab from the Steam VR Plugin was the source of one of the bugs found during development of this prototype. It was not found until very late in the process as the scenes were usually only tested individually, and not after transitioning from one to the other. As it turned out the player prefab was not destroyed on scene change, and every scene had one of these player prefabs, which meant there would be several player objects in the scene after the first scene was left. This was not obvious as most of my scenes had the player object in the exact same spot and they were just overlapping each other. However, when transitioning from a scene were this object was in another position than the previous scene, it became very obvious as one could see two laser pointers originating from different spots. The solution to this was to have create a pre start scene scene and a fallback prefab. Having this scene and fallback prefab also turned out to be a better architectural design. The idea behind was to create/load all the game objects which was common to all scenes in this pre start scene, and not destroy them on scene changes. The fallback prefab would be added to all other scenes and if the game had not been started from the pre start scene it would do the same as the pre start scene would; load the common objects and components.



%the player
\subsection{Features}
The following features were present in the final version of the prototype:

\subsubsection{Common to all scenes}
\begin{itemize}
    \item Player - A camera and controller reflecting the physical orientation and position of the player hand his/her hands/controllers. Also has a laser pointer in the right hand for interacting with the world
    \item Show outline on interactive objects when hovering over with the laser pointer
    \item Interact with interactive objects by pressing the trigger button on the controller with the laser pointer while pointing at it
    \item Buttons - Interactive object
\end{itemize}

\subsubsection{Over world}
\begin{itemize}
    \item Show available courses as different buttons
    \item Course buttons - Loads the button's course
    \begin{itemize}
        \item Algorithms and Data Structures
    \end{itemize}
\end{itemize}

\subsubsection{Algorithms and Data Structures}
\textbf{Course hub(entry point):}
\begin{itemize}
    \item Show available topics as buttons
    \item \textbf{Topic buttons} - Loads the button's topic
    \begin{itemize}
        \item Data structures
        \item Sorting algorithms
    \end{itemize}
    \item Back navigation button - Go back to the over world
\end{itemize}

\textbf{Data structures:}
\begin{itemize}
    \item \textbf{Play mode} - Learn how the selected structure works
    \begin{itemize}
        \item Show available structures as buttons
        \item \textbf{Structure buttons} - Go to play mode for selected structure
        \begin{itemize}
            \item Stack
            \item Queue
        \end{itemize}
        \item \textbf{Stack and Queue} - Same play mode
        \begin{itemize}
            \item Show a representation of the data structure
            \item Push/Enqueue button - Animate how the structure handles addition of data
            \item Pop/Dequeue button - Animate how the structure handles removal/retrieval of data
            \item Use case button - Go to use case mode for this structure
            \item Back navigation button - Go back to course hub
            \item Show explanation of each button
            \item Show error message when doing an illegal action containing the error (Overflow/Underflow) and when it occurs
        \end{itemize}
    \end{itemize}
    \item \textbf{Use case mode} - See how the selected structure can be used in a real life scenario
    \begin{itemize}
        \item \textbf{Stack and Queue} - Same use case: Image region growing
        \begin{itemize}
            \item Back navigation button - Go back to play mode for this structure
            \item Show a description of what this use case is when entering the use case mode. Press the button on this panel to hide it and start the algorithm.
            \item Show a black and white image with random pattern. Each pixel is an interactive object.
            \item Pixel(interactive object) - Select (show a border color to indicate that it is selected)
            \item Show a representation of the data structure selected before entering use case mode
            \item Show a representation of the the item from the data structure is currently being read/used ("Next" as it points to the next pixel to check)
            \item Show a representation of the internal state of the algorithm (Pattern so far, visited pixels, which pixel is next, etc...)
            \item Show an explanation of the color coding in the representation of the algorithm
            \item \textbf{Action buttons}
            \begin{itemize}
                \item Push/Enqueue - Animate addition of the selected Pixel to the data structure
                \item Pop/Dequeue - Animate removal of next pixel from the data structure and into the "Next" position. 
                \item Check - Animate the checking(whether it is or is not part of the pattern) of the pixel.
            \end{itemize}
            \item \textbf{Algorithm interaction buttons}
            \begin{itemize}
                \item Demo(toggle button) - Start/stop the demonstration of the algorithm. The demonstration animates how the algorithm works step by step.
                \item Prev - Undo the last step in the algorithm(animate)
                \item Next - Do the next step in the algorithm(animate)
            \end{itemize}
            \item An attempt at doing an action the algorithm does not expect, it will not perform the action and instead hint at the expected action by blinking the required elements and action button a few times. 
            \item Data items popped or dequeued into "Next" will fire a laser at the pixel it represents. To indicate which pixel should be checked next
        \end{itemize}{}
    \end{itemize}
\end{itemize}

\textbf{Sorting Algorithms}
\begin{itemize}
    \item Back navigation button - Go back to course hub
    \item Show available sorting algorithms as buttons
    \item Show the array as a horizontal set of cuboids(array elements) on top of another cuboid(array stand or representation of the memory location). The elements has a height relative to their value: high value means a tall cuboid, and a low value means a short cuboid.  
    \item Both the array and the the elements are interactive
    \item Show a Cube representing the storage (where array elements can be temporarily stored)
    \item Show a representation of the internal state of the algorithm
    \item Show pseudo code for the selected algorithm
    \item \textbf{Sorting algorithm buttons} - Generates a new random array and changes to this algorithm
    \begin{itemize}
        \item Bubble sort
        \item Insertion sort
        \item Quick sort
        \item Merge sort
    \end{itemize}
    \item \textbf{Algorithm interaction buttons}
    \begin{itemize}
        \item Demo(toggle button) - Start/stop demonstrating the algorithm. The demonstration shows the algorithm step by step in the correct order and explains what it is doing.
        \item Prev - Undo the last step in the algorithm(animate)
        \item Next - Do the next step in the algorithm(animate)
        \item New array - Generate a new random array
        \item Restart - Resets the algorithm, and array back to start    
    \end{itemize}
    \item \textbf{Action buttons}
    \begin{itemize}
        \item Compare - Compare the value of two elements
        \item Swap - Swap the values/position of one or two element(s)
        \item Store - Clone one of the elements in the array to the storage
        \item Copy to - Two step action: Copy selected element value into the next selection (limitations: can not copy to storage, use Store instead)
        \item Pivot - Sets the selected element as a pivot
        \item Split - Splits the selected array in two halves
        \item Merge - Start the merge of two arrays
    \end{itemize}
    \item Show which buttons are disabled by changing their color, and the color of the outline when hover over
    \item An attempt at doing an action the algorithm does not expect, it will not perform the action and instead hint at the expected action by blinking the required elements and action button a few times. 
    
\end{itemize}

