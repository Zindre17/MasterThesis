\section{Discussion}
\label{sec:Discussion}
\todo{Denne delen trenger fortsatt mye jobb}

% this can be in the discussion somewhere: but beware the code is practically only self commented. And not even that well self commented. I felt no need to comment the code, as I was constantly revisiting old code and doing improvements, and knew it pretty much inside out without the commenting. There were occasions where some comments could have saved me some time during some refactors though.

This chapter will process the information and experience gathered and gained throughout the development and testing, and reflect around them. What was done well? What could have been done better? What have I learned? Does the results make sense? Is the data gathered sufficient for reaching a conclusion? Questions like these are what you will find reflections around in this chapter. Starting with the process and planning, then moving on to the development, the testing after that, and finally the results.

\subsection{Planning and Process}
%When it comes to planning, it would seem as though the previous project was completely forgotten as I have learned next to nothing from it when it comes to planning and process. The same mistakes done in the previous project repeated. Too little upfront planning, and just diving straight into the development. However, the biweekly meeting with my supervisor forced me to plan a bit ahead, and it gave me a sense of direction and also some sense of urgency to complete certain tasks, or reach certain milestones.

%If I were to try to defend the "jumping right into coding and skipping planning" it would be that creating a game is a highly creative task. And coming up with ideas for improvements or new features can be really hard without actually having anything as reference. Therefore, just developing something, and then testing it might give inspiration for new ideas. On the other hand just making something without a solid plan usually comes with a bunch of spaghetti code. Which will probably need to be rewritten at some point and it might be a time consuming task. Maybe more so than properly planning the architecture/structure in advance. 



\subsection {Development}

As an after thought, the way I handled animations was probably not the most efficient way. And by efficient, I mean efficient in terms of creating, not in terms of execution and performance. The animations were all done by code, which is kind of waste when there exists a tool for creating animations in the Unity editor. Using the tool in Unity allows for a visual generation of animations, which is a lot easier than sketching or imagining the different positions and rotations it should have throughout the animation. In the beginning of the project some experimentation was done with the animator tool, but, as a coder, it felt a bit weird. The tool seemed fairly easy to use, at least for objects already in the scene. The problems began when I needed the animation to spawn different objects and then do animations on them. I will admit that not a lot of effort was put in to figuring out this, and instead decided to settle for writing the animations with code, because I already knew how to do it this way.

A part of the architecture or structure of the game which was not done optimally, was also linked to the animations. A lot of the animations contained logic in them, which made the scene reliant on the animations completing properly for the game to behave properly. This is bad design, and was the cause for a lot of the bugs having to be dealt with at the end of the development. Removing the logic from the animations would require some components to keep track of more states, but the payoff would be huge in terms of clean code, and less error prone code. 

During the development, I always had performance in mind, as VR games need to run smoothly in order to decrease the strain on the user in terms of getting motion sick. This made me very hesitant of using the inbuilt ``Update'' method of all the components. This method runs every frame for every component in the scene, and therefore means that doing a lot of work in these methods is a bad idea. However, The scenes in this prototype does not contain a lot of components compared to a lot of other games, and I overestimated the performance hit of using this method for small things. The work-arounds also caused a lot time loss due to putting logic which could have gone into the ``Update'' method in the ``Start'' or ``Awake'' methods instead. This caused a lot of null pointer exceptions due methods being called on instances not yet created, due to the nature of order of creation in scene elements. It also made debugging harder as the things happening is not just tied to the update method, but instead tied to many methods all over the place. This also makes it harder for new people to read and understand the flow of the code. I was even hesitant to use the ``Update'' method in combination with a boolean which it would check before doing any actual work, because I thought that the act of checking this boolean every frame could impact performance. The reality is that it will not affect the performance, unless there are a vast amount of components. The only component, or one of very few, I created which utilized this method was the ``EventManager''. This component used to update method to shoot a ray cast from the laser every frame to decide the length of the laser and also to interact whith what it was pointed towards. The point here is that using the ``Update'' method would have simplified a lot of things, made the code cleaner and easier to read, and less buggy. Lesson learned.


\subsection{Testing}
Testing was supposed to have started in late April or early May, but ended up happening mid May. The reason for this was a mixture of things. I was attending a confirmation of my cousin in Stavanger, and due to the SAS-strike I had to travel earlier than needed, and I got home later than planned. During this period I was not able to work too much on the project. This was late in April. Another reason was that I had a realization when I was showing VR to a friend and she wanted to see what I was making. I realized a bunch of tweaks I could make to improve the usability. And some of these tweaks took a lot longer to implement than I had thought. And since quite a few bugs were found in the last projects testing, I thoroughly tested the application in ways it was not meant to be used. This unveiled many bugs which I had not noticed earlier because I, the creator, know how the application is supposed to work and use it thereafter when testing new features. However, some of these bugs were surprisingly hard to squish, but As the testing went smoothly around this time, it seems it was not in vain. 

\subsection{Results}

\subsection{Possible Improvements}
First of all, from the test results, it is very clear that the prototype is still not quite intuitive enough. The first thing which came to mind when observing the testing, in regards to improving the prototype, was to implement some form of tutorial for every topic in every course. This tutorial should be an interactive explanation of what is possible to do in the scene for the selected topic. If done correctly this should familiarize the player with all the actions which are possible to perform and what all the objects in the scene represent and which states they can be in. However, this tutorial should always be optional as it will bore players already familiar, degrading their user experience. 

Based on some of the feedback given after the tests, it was explained that it was hard to understand what was happening in the use case scenario for the queue and stack. A suggestion from one of the testers for making this more clear was to highlight the most recent action in the state representation. I agree, this was a good suggestion. Another thing several of the testers suggested was to show which line of code was being executed at the moment, making it easier to follow the sorting algorithms. This is a feature which I knew the other person doing the same task as me in parallel had implemented, and was one I had considered. In hind sight I wish I had implemented this, as it is kind of an obvious winner in terms of making things clear. However, for some reason I did not realize that this was needed, in time. 

\begin{comment}
%diskut√©r resultatene 
Discussion

Planning/Process
The process in this project was handled a bit unprofessionally. I was more eager to develop rather than plan the development. This is not necessarily a bad thing, but the way I handled it could have been much better. The way I did it was that I got an idea of how i wanted the prototype to be, then start to make it. Eventually I would come to a point where I had something which could have been tested, but something about it was not to my liking and I came up with a new design to implement, instead of testing it and basing the new design on feedback from others. This happened at least two times during the project, and cost me a lot of time, with little benefit as I wasted good opportunities to get good feedback.  

Test Results
Now, let us talk a bit about the results from the usability testing. The tests resulted with a SUS score of 67.5 at average. The individual results, however, show that there is a high variance, with the highest score of 85, and the lowest score of 42.5. The thing to take note of here, I think, is that the test subject which gave the lowest score had not taken the course Algorithms and data structures, or any other computer science related subjects, while the other test subjects had taken that course. If we only include the test subjects which had taken this course, the average rises to 75.83, which is a fairly good score. This suggests that the usability of the prototype is linked to the knowledge of the subject, and this is understandable, but might not be a good thing. Because of this, it also suggests that this prototype will perform poorly if used by it self, and not as a supplement to the course. The goal was to make something which could be used as a supplement, but it would, of course, have been nice if it ended up having been self sustainable as well. However, this is only for the usability and does not say anything about the learning/teaching done through this prototype. To test learning is a much more time consuming endeavor. It needs to be done over a longer period of time, and multiple tests, to check for prior understanding, understanding immediately after, and retained knowledge at some point later. This fell outside of the scope of this project.

Research Questions
The first research question introduced int this article was weather VR can be used to help teach complex subjects, and how. Assuming the first part is true, the second part, the "how", then has infinite possibilities. The produced prototype is an attempt at answering this. Weather it accomplishes it is yet to be known. However, the usability test show that people who know something about the subject, find the prototype usable, and might therefor want to use it. This also answers the second question, of how usable the proposed solution is. But then again, usability does not equal engagement(User experience vs Player experience \cite{lazzaro}). And engagement is what one desires in a learning situation. On the other side, bad usability invokes frustration, and not necessarily the good kind of frustration which can transition into mastery. 
\end{comment}