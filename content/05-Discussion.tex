\section{Discussion}
This chapter will process the information and experience gathered and gained throughout the development and testing, and reflect around them. What was done well? What could have been done better? What have I learned? Does the results make sense? Is the data gathered sufficient for reaching a conclusion? Questions like these are what you might find in this chapter. Starting with the process and planning, then moving on to the development, the testing after that, and finally the results.

\subsection{Planning and Process}
When it comes to planning, it would seem as though the previous project was completely forgotten as I have learned next to nothing from it when it comes to planning and process. The same mistakes done in the previous project repeated. Too little upfront planning, and just diving straight into the development. However, the biweekly meeting with my supervisor forced me to plan a bit ahead, and it gave me a sense of direction and also some sense of urgency to complete certain tasks, or reach certain milestones.

If I were to try to defend the "jumping right into coding and skipping planning" it would be that creating a game is a highly creative task. And coming up with ideas for improvements or new features can be really hard without actually having anything as reference. Therefore, just developing something, and then testing it might give inspiration for new ideas. On the other hand just making something without a solid plan usually comes with a bunch of spaghetti code. Which will probably need to be rewritten at some point and it might be a time consuming task. Maybe more so than properly planning the architecture/structure in advance. 



\subsection {Development}

As an after thought, the way I handled animations was probably not the most efficient way. And by efficient, I mean efficient in terms of creating, not in terms of execution and performance. The animations were all done by code, which is kind of waste when there exists a tool for creating animations in the Unity editor. Using the tool in Unity allows for a visual generation of animations, which is a lot easier than sketching or imagining the different positions and rotations it should have throughout the animation. In the beginning of the project some experimentation was done with the animator tool, but, as a coder, it felt a bit weird. The tool seemed fairly easy to use, at least for objects already in the scene. The problems began when I needed the animation to spawn different objects and then do animations on them. I will admit that not a lot of effort was put in to figuring out this, and instead decided to settle for writing the animations with code, because I already knew how to do it this way.

%this might actually go in the result part instead...
The way the animations were coded was by using coroutines. Couroutines are a part of the UnityEngine library, and they work by defining a function with a return type of IEnumerator, and should contain the code for doing the animation, i.e move, rotate, and or scale objects. And to start the defined animation one needs to call the StartCoroutine function and provide the animation function as a parameter to that function. 
Like this:
\begin{lstlisting}[language=C]
IEnumerator SomeAnimation(){
    float duration = .6f;
    float elapsed = 0f;
    float prevTime = Time.time;
    //This while loop will run one iteration of the loop every frame for .6 seconds. This makes the animation's duration independent of the frame-rate
    while(elapsed < duration){
        // Do something every frame here
        ...
        float time = Time.time;
        elapsed += time - prevTime;
        prevTime = time;
        yield return null;
    }
    //Do something at the end of the animation here
    ...
}

...
// Somewere inside a function which should trigger the SomeAnimation animation
StartCoroutine(SomeAnimation());
\end{lstlisting}

The special part about these coroutines is that is executes code until it reaches a "yield return ..." statement, then it will stop executing, and then continue from where it left off at the next frame. There is no limit on the amount of "yield return ..." statements a coroutine can have. the value after "yield return" can be either null or one of several different types for waiting specific times until resuming execution, like a set amount of time in seconds, or at the end of the frame instead of the beginning of the frame, and so on. 

\subsection{Testing}
Testing was supposed to have started in late April or early May, but ended up happening mid May. The reason for this was a mixture of things. I was attending a confirmation of my cousin in Stavanger, and due to the SAS-strike I had to travel earlier than needed, and I got home later than planned. During this period I was not able to work too much on the project. This was late in April. Another reason was that I had a realization when I was showing VR to a friend and she wanted to see what I was making. I realized a bunch of tweaks I could make to improve the usability. And some of these tweaks took a lot longer to implement than I had thought. And since quite a few bugs were found in the last projects testing, I thoroughly tested the application in ways it was not meant to be used. This unveiled many bugs which I had not noticed earlier because I, the creator, know how the application is supposed to work and use it thereafter when testing new features. However, some of these bugs were surprisingly hard to squish, but As the testing went smoothly around this time, it seems it was not in vain. 

\subsection{Results}

\subsection{Possible Improvements}
First of all, from the test results, it is very clear that the prototype is still not quite intuitive enough. The first thing which came to mind when observing the testing, in regards to improving the prototype, was to implement some form of tutorial for every topic in every course. This tutorial should be an interactive explanation of what is possible to do in the scene for the selected topic. If done correctly this should familiarize the player with all the actions which are possible to perform and what all the objects in the scene represent and which states they can be in. However, this tutorial should always be optional as it will bore players already familiar, degrading their user experience. 

Based on some of the feedback given after the tests, it was explained that it was hard to understand what was happening in the use case scenario for the queue and stack. A suggestion from one of the testers for making this more clear was to highlight the most recent action in the state representation. I agree, this was a good suggestion. Another thing several of the testers suggested was to show which line of code was being executed at the moment, making it easier to follow the sorting algorithms. This is a feature which I knew the other person doing the same task as me in parallel had implemented, and was one I had considered. In hind sight I wish I had implemented this, as it is kind of an obvious winner in terms of making things clear. However, for some reason I did not realize that this was needed, in time. 

\begin{comment}
%diskutÃ©r resultatene 
Discussion

Planning/Process
The process in this project was handled a bit unprofessionally. I was more eager to develop rather than plan the development. This is not necessarily a bad thing, but the way I handled it could have been much better. The way I did it was that I got an idea of how i wanted the prototype to be, then start to make it. Eventually I would come to a point where I had something which could have been tested, but something about it was not to my liking and I came up with a new design to implement, instead of testing it and basing the new design on feedback from others. This happened at least two times during the project, and cost me a lot of time, with little benefit as I wasted good opportunities to get good feedback.  

Test Results
Now, let us talk a bit about the results from the usability testing. The tests resulted with a SUS score of 67.5 at average. The individual results, however, show that there is a high variance, with the highest score of 85, and the lowest score of 42.5. The thing to take note of here, I think, is that the test subject which gave the lowest score had not taken the course Algorithms and data structures, or any other computer science related subjects, while the other test subjects had taken that course. If we only include the test subjects which had taken this course, the average rises to 75.83, which is a fairly good score. This suggests that the usability of the prototype is linked to the knowledge of the subject, and this is understandable, but might not be a good thing. Because of this, it also suggests that this prototype will perform poorly if used by it self, and not as a supplement to the course. The goal was to make something which could be used as a supplement, but it would, of course, have been nice if it ended up having been self sustainable as well. However, this is only for the usability and does not say anything about the learning/teaching done through this prototype. To test learning is a much more time consuming endeavor. It needs to be done over a longer period of time, and multiple tests, to check for prior understanding, understanding immediately after, and retained knowledge at some point later. This fell outside of the scope of this project.

Research Questions
The first research question introduced int this article was weather VR can be used to help teach complex subjects, and how. Assuming the first part is true, the second part, the "how", then has infinite possibilities. The produced prototype is an attempt at answering this. Weather it accomplishes it is yet to be known. However, the usability test show that people who know something about the subject, find the prototype usable, and might therefor want to use it. This also answers the second question, of how usable the proposed solution is. But then again, usability does not equal engagement(User experience vs Player experience \cite{lazzaro}). And engagement is what one desires in a learning situation. On the other side, bad usability invokes frustration, and not necessarily the good kind of frustration which can transition into mastery. 
\end{comment}