\section{Discussion}
\label{sec:Discussion}

% this can be in the discussion somewhere: but beware the code is practically only self commented. And not even that well self commented. I felt no need to comment the code, as I was constantly revisiting old code and doing improvements, and knew it pretty much inside out without the commenting. There were occasions where some comments could have saved me some time during some refactors though.

This chapter will process the information and experience gathered and gained throughout the development and testing, and reflect around them. What was done well? What could have been done better? What have I learned? Does the results make sense? Is the data gathered sufficient for reaching a conclusion? Questions like these are what you will find reflections around in this chapter. Starting with the research questions, next the process and planning, then moving on to the development, the testing after that, and finally the results.

\subsection{Summary}
To sum up the results of this project, I would like to address the research questions proposed in the introduction.

\subsubsection{RQ1}
\textbf{\textit{``Is the new prototype improved compared to the previous version?''}}. Yes, the prototypes is improved somewhat. It has improved in terms of usability according to the SUS score, with a bigger sample group, though not by a lot. The lesson learned here is that there should \textit{always} be a tutorial. There was also added quite a bit of new content to the prototype. The new content was of very similar form to the existing content and was therefor not a bottleneck in terms of usability. There is no empiric data to show whether the new prototype is better or worse at teaching players, or whether or not it is more fun to use. 

\subsubsection{RQ2}
\textbf{\textit{``Do people think VR is suited in a school or learning setting?''}}. The short answer here is: yes. All the participants of the testing thinks VR is suited in a learning setting. This might be a bit biased as all the participants study technology, but their thoughts should not be ignored either. I think that VR will be more utilized for learning in the future. 

\subsubsection{RQ3}
\textbf{\textit{``Will the developed prototype indicate that using VR might be suited for teaching/learning?''}}. Despite some usability issues, most of the participants of the testing though that an application similar to the prototype could aid in the learning process. However, not quite as many as those who thought VR in general could be useful for learning, suggesting this game should have done something differently.


\subsection{Planning and Process}
%When it comes to planning, it would seem as though the previous project was completely forgotten as I have learned next to nothing from it when it comes to planning and process. The same mistakes done in the previous project repeated. Too little upfront planning, and just diving straight into the development. However, the biweekly meeting with my supervisor forced me to plan a bit ahead, and it gave me a sense of direction and also some sense of urgency to complete certain tasks, or reach certain milestones.

%If I were to try to defend the "jumping right into coding and skipping planning" it would be that creating a game is a highly creative task. And coming up with ideas for improvements or new features can be really hard without actually having anything as reference. Therefore, just developing something, and then testing it might give inspiration for new ideas. On the other hand just making something without a solid plan usually comes with a bunch of spaghetti code. Which will probably need to be rewritten at some point and it might be a time consuming task. Maybe more so than properly planning the architecture/structure in advance. 
The planning and process was not done in a very structured manner. The upfront planning was minimal, and focused more on just making something and then see where to go from there. It was kind of like being on a journey through nature, and scouting a general direction to walk whenever at a peak or high point, then just stumbling along in this direction until stopping at a new point and repeating this process. The biggest obstacles along these paths were the design choices. ``How should I represent this in VR?'' or ``What parts of this subject is important to emphasise?'' and so on. The peaks and high points, were the meetings with my supervisor, where we discussed what had been done, and find the general direction to walk until the next meeting. These meetings with my supervisor were scheduled bi-weekly, with a few exceptions, and they gave me a sense of direction and also some sense of urgency to complete certain tasks, or reach certain milestones. Despite this, there were periods with low productivity due to lack of motivation. Especially in the beginning. I was struggling with a lot of design issues, and how I wanted things to work, and this killed my motivation for quite some time. I would get things done, but not anything beyond that. It was not until late March or early April, when I finally picked up the pace and found some motivation again. I think that this project would have benefited hugely by having a member dedicated to designing the game(concepts and functionality), and me doing the code, because coding is something I am a lot more passionate about. It would also benefit in general by having more people on board, as making a game requires many very different different skills. Games are a combination of graphics, game design, sound, music, code, and more. Doing all of this as one person is really hard. 


\subsection {Development}

As an after thought, the way I handled animations was probably not the most efficient way. And by efficient, I mean efficient in terms of creating, not in terms of execution and performance. The animations were all done by code, which is kind of waste when there exists a tool for creating animations in the Unity editor. Using the tool in Unity allows for a visual generation of animations, which is a lot easier than sketching or imagining the different positions and rotations an object should have throughout the animation. In the beginning of the project some experimentation was done with the animator tool, but, as a coder, it felt a bit weird. The tool seemed fairly easy to use, at least for objects already in the scene. The problems began when I needed the animation to spawn different objects and then do animations on them. I will admit that not a lot of effort was put in to figuring out this, and instead decided to settle for writing the animations with code, because I already knew how to do it this way.

A part of the architecture or structure of the game which was not done optimally, was also linked to the animations. A lot of the animations contained logic in them, which made the scene reliant on the animations completing properly for the game to behave properly. This is bad design, and was the cause for a lot of the bugs having to be dealt with at the end of the development. Removing the logic from the animations would require some components to keep track of more states, but the payoff would be huge in terms of clean code, and less error prone code. 

During the development, I always had performance in mind, as VR games need to run smoothly in order to decrease the strain on the user in terms of getting motion sickness. This made me very hesitant of using the inbuilt ``Update'' method of all the components. This method runs every frame for every component in the scene, and therefore means that doing a lot of work in these methods is a bad idea. However, The scenes in this prototype does not contain a lot of components compared to a lot of other games, and I overestimated the performance hit of using this method for small things. The work-arounds also caused a lot time loss due to putting logic which could have gone into the ``Update'' method in the ``Start'' or ``Awake'' methods instead. This caused a lot of null pointer exceptions due methods being called on instances not yet created, due to the nature of order of creation in scene elements. It also made debugging harder as the things happening is not just tied to the update method, but instead tied to many methods all over the place. This also makes it harder for new people to read and understand the flow of the code. I was even hesitant to use the ``Update'' method in combination with a boolean which it would check before doing any actual work, because I thought that the act of checking this boolean every frame could impact performance. The reality is that it will not affect the performance, unless there are a vast amount of components. The only component, or one of very few, I created which utilized this method was the ``EventManager''. This component used to update method to shoot a ray cast from the laser every frame to decide the length of the laser and also to interact with what it was pointed towards. The point here is that using the ``Update'' method would have simplified a lot of things, made the code cleaner and easier to read, and less buggy. Lesson learned.


\subsection{Testing}
The user testing was supposed to have started in late April or early May, but ended up happening mid May. The reason for this was a mixture of things. I was attending a confirmation of my cousin in Stavanger, and due to the SAS-strike I had to travel earlier than needed, and I got home later than planned. During this period I was not able to work too much on the project. This was late in April. Another reason was that I had a realization when I was showing VR to a friend and she wanted to see what I was making. I realized that I had not really addressed the usability issues found in the previous project and I had come up with a few other tweaks I could make to improve the usability as well. And some of these tweaks took a lot longer to implement than I had thought. The start of May went into this part(\autoref{sec:It6}). And since quite a few bugs were found in the last project's user testing, I thoroughly tested the application in ways it was not meant to be used. This unveiled many bugs which I had not noticed earlier because I, the creator, know how the application is supposed to work and use it thereafter when testing new features. However, some of these bugs were surprisingly hard to squish and took quite a lot of time to fix, but As the user testing went smoothly around this time, it seems it was not in vain. No bugs were encountered during the user testing performed of the new prototype.

In regards to the participants of the user testing, they were all acquaintances or friends of mine. This means there might be some bias in the answers. The prototype was about learning a computer science course, and therefore people within this field of study is preferred for testing. Since I am also part of this field of study, it was always a risk of this happening. Nevertheless, this does not mean the results are useless, just that they need to be judged more critically. Having the answers collected be through an anonymous questionnaire, might mitigate some of the bias which could have been stronger if the answers were gathered through an interview. The quantity of participants was not very large, and could have gotten more accurate results if it had been bigger. However, the SUS does not require a large sample to be accurate, which is a saving grace for this project. 

\subsection{Results}
This bit will discuss both the developed prototype and the results of the user tests. The prototype will be discussed in terms of what about it is backed by theory, what is done in spite of theory, and what could have been done differently. The testing will be discussed based on the different metrics gathered and what they could indicate.

\subsubsection{Prototype}
As suggested by the the multimedia learning theories, the use of voice is suggested to replace text(\autoref{sec:MLT}). This was known in advance of the development, but despite this, there is no sound in the game. This means that the input load will only be handled by the visual ``channel'' instead of spread across the auditory and visual ``channels''. The addition of adding voice had long been a part of the plan, but it was never actually done. I guess the reason for putting it off for so long was that I did not have proper recording gear easily available to me, and that I did not really want my voice to be in the game. I considered using an artificial voice(text-to-speech software) instead, but this was advised against from the theory. 

%

%The results of the testing show that the prototype is still not intuitive enough. People still struggle to understand some parts of the game. However, there are improvements. People better understand what each room is supposed to do. The problem seems to be that users do not understand that actions can be performed manually as well as shown with ``Demo'' and ``Do next step''.
%feedback




%SUS
\subsubsection{Usability}
The SUS questionnaire yielded an average score of 70.3 as presented in the results chapter. This means that the usability of this prototype is slightly higher than that of the average application, assuming there is no bias present in the score. The visual observations made during the user testing seem to indicate that bias is present and that the score from the questionnaire got a higher score than it should have. Even just a single point lower score in one of the ten statements from all the participants would drag the score down to slightly below average(70.3 - 2.5 = 67.8). Only few of the participants were able to figure out that algorithms could be done manually and this is a pretty huge flaw. Only being able to watch the algorithms is not quite the same as actively participating, even though the application does not require the user to do things manually. Some might find it enough to just watch to learn the algorithm, but I believe there is merit to ``learning by doing''.  

%usefulness
\subsubsection{Usefulness}
100\% of all the participants, thinks VR could be helpful for teaching/learning. The sample is not huge, but it makes sense. The quality of the VR hardware today makes VR very immersive, and immersion is on some level very similar to focus, and focus is needed when learning. It also gives the ability to go anywhere or do anything, which is not possible in a normal classroom setting. The response from this question is therefor not a surprise at all. Most of the participants even thought that an application similar to the prototype could be helpful, and the prototype was not even that easy to use, showing just how much they believe in VR.

%negative emotions
\subsubsection {Motion Sickness}
There are side effects present in the current hardware of VR, and some are more susceptible than others. The side effect I am referring to is of course the infamous motion sickness. The root of motion sickness comes from the brain receiving different signals of motion from different senses. Which is why one can easily get sick when reading a book or playing a game in the car; the eyes detect no motion, but the inner ear does detect motion\cite{MotionSickness}. 
It is said that the games where players are more prone to getting sick are games with locomotion and games with low frame rate. Avoiding these two will reduce the chance of players getting sick. Popular replacements for locomotion is teleportation, and in games where the player can use the joy stick on the controller to turn the camera, having it turn in chunks in stead of continuously is also preferred by most. The prototype does not contain locomotion nor camera control through the joystick, and the frame rate was not limited by the software, as far as I am aware. Despite this, about a third of the participants were somewhat affected by this. The triggers for this based on their feedback seemed to be from the sorting area, where the player is standing on a box to get some more height and a better view of everything, and from the sudden change in the environment when changing from play mode and use case mode in the data structure scene. The box in the sorting scene could not always be seen, depending on how far forward the player was standing. Not seeing the box one was standing on made it seem like the player was twice as tall or standing on a cliff. This was not optimal for avoiding sickness. The sudden change in the data structure scene were experienced as too intense by some of the participants.

\subsection{Reflections}
A possible solution for the problem of players not figuring out that algorithms can be performed manually, is to implement some form of optional tutorial, where the player will be presented with interactive explanations for everything possible to do within a scene. Having it be optional is important to avoid boring the players which already knows how things work.  

Based on some of the feedback given after the user testing, it was explained that it was hard to understand what was happening in the use case scenario for the queue and stack. This was due to many things happening at once and there was no indication as to what action the user had just made. A suggestion from one of the testers for making this more clear was to highlight the most recent action in the state representation. I agree, this was a good suggestion. 

Another thing several of the testers suggested was to show which line of code was being executed at the moment, making it easier to follow the sorting algorithms. This is a feature which I knew the other person doing the same task as me in parallel had implemented, and was one I had considered. In hindsight I wish I had implemented this, as it is kind of an obvious winner in terms of making things clear. However, for some reason I did not realize that this was needed, in time. 

%First of all, from the test results, it is very clear that the prototype is still not quite intuitive enough. The first thing which came to mind when observing the testing, in regards to improving the prototype, was to implement some form of tutorial for every topic in every course. This tutorial should be an interactive explanation of what is possible to do in the scene for the selected topic. If done correctly this should familiarize the player with all the actions which are possible to perform and what all the objects in the scene represent and which states they can be in. However, this tutorial should always be optional as it will bore players already familiar, degrading their user experience. 

%Based on some of the feedback given after the tests, it was explained that it was hard to understand what was happening in the use case scenario for the queue and stack. A suggestion from one of the testers for making this more clear was to highlight the most recent action in the state representation. I agree, this was a good suggestion. Another thing several of the testers suggested was to show which line of code was being executed at the moment, making it easier to follow the sorting algorithms. This is a feature which I knew the other person doing the same task as me in parallel had implemented, and was one I had considered. In hind sight I wish I had implemented this, as it is kind of an obvious winner in terms of making things clear. However, for some reason I did not realize that this was needed, in time. 


\begin{comment}
%diskut√©r resultatene 
Discussion

Planning/Process
The process in this project was handled a bit unprofessionally. I was more eager to develop rather than plan the development. This is not necessarily a bad thing, but the way I handled it could have been much better. The way I did it was that I got an idea of how i wanted the prototype to be, then start to make it. Eventually I would come to a point where I had something which could have been tested, but something about it was not to my liking and I came up with a new design to implement, instead of testing it and basing the new design on feedback from others. This happened at least two times during the project, and cost me a lot of time, with little benefit as I wasted good opportunities to get good feedback.  

Test Results
Now, let us talk a bit about the results from the usability testing. The tests resulted with a SUS score of 67.5 at average. The individual results, however, show that there is a high variance, with the highest score of 85, and the lowest score of 42.5. The thing to take note of here, I think, is that the test subject which gave the lowest score had not taken the course Algorithms and data structures, or any other computer science related subjects, while the other test subjects had taken that course. If we only include the test subjects which had taken this course, the average rises to 75.83, which is a fairly good score. This suggests that the usability of the prototype is linked to the knowledge of the subject, and this is understandable, but might not be a good thing. Because of this, it also suggests that this prototype will perform poorly if used by it self, and not as a supplement to the course. The goal was to make something which could be used as a supplement, but it would, of course, have been nice if it ended up having been self sustainable as well. However, this is only for the usability and does not say anything about the learning/teaching done through this prototype. To test learning is a much more time consuming endeavor. It needs to be done over a longer period of time, and multiple tests, to check for prior understanding, understanding immediately after, and retained knowledge at some point later. This fell outside of the scope of this project.

Research Questions
The first research question introduced int this article was weather VR can be used to help teach complex subjects, and how. Assuming the first part is true, the second part, the "how", then has infinite possibilities. The produced prototype is an attempt at answering this. Weather it accomplishes it is yet to be known. However, the usability test show that people who know something about the subject, find the prototype usable, and might therefor want to use it. This also answers the second question, of how usable the proposed solution is. But then again, usability does not equal engagement(User experience vs Player experience \cite{lazzaro}). And engagement is what one desires in a learning situation. On the other side, bad usability invokes frustration, and not necessarily the good kind of frustration which can transition into mastery. 
\end{comment}