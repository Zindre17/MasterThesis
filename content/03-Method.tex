%denne delen skal forklare hvordan spillet har blitt implementert og hvordan teorien har blitt utnyttet
\section{Method}
This section will present how the prototype was planned and reasoning behind decisions made, as well as which features and functionality should be implemented in Unity.

%?????

\subsection{Previous Work}
%say something about what changed from the prev project to this
As already stated, this project is a continuation of another project. The prototype developed in that project consisted of a single scene, which was for teaching sorting algorithms. This scene had implemented two sorting algorithms: bubble sort and insertion sort. \href{https://youtu.be/7m7B7zJ4KIQ}{Click here} to see a video of the functionality and contents of the first prototype. The interaction was purely through pointing with a laser in the right hand and pressing the trigger when pointing at objects which were interactive. This prototype was also user tested, though only by 5 people. The user test consisted mainly of a usability test, utilizing the standard System Usability Scale, or SUS for short. The SUS is a set of 10 questions regarding usability where the answers should be in a range of one to five. What the results of this testing showed was that usability was closely linked with the whether the player had taken the course or not. But due to the small scale of the testing, the results should in no way be treated as conclusive.  %However, this laser pointer was based on the mesh of a gun, and it confused the users, as it suggested to them that they had to defend themselves from something within the game.

\subsection{Design}
As can be seen in video of the previous prototype, the design of the scene where the sorting happens is formed kind of like a semi circle. To the front, the representation of the array is shown, with the array elements represented as yellow cuboids with height visually representing their value, and the array itself represented as a cuboid laying on the ground with its elements hovering above it. To the left of the array, still to the front, lies a cube representing the storage area, where algorithms needing to save values outside of the array can place them. On the floor in front of where the player stands, there is a panel. This panel shows the state of the algorithm, the pseudo code for the algorithm, and shows output from the most recent comparison of elements. To the left are two walls with buttons aligned vertically. One for selecting algorithm, and one with buttons for starting a demonstration of the algorithm, starting the algorithm over again, and getting a new randomly generated array. The buttons are thin cuboids with big labels on them representing their respective actions. The other side, to the right, contains a wall with action buttons. The available actions are compare, swap, store, and copy to.

Reading a value as a number in text is easy, Seeing the value as the length of an object is easier. That is the reasoning behind the design of the array elements. The two projects the previous projects took inspiration from mainly used cubes of equal size, though an option to show the difference in size as one shrinking and one growing was available in one of them. The reason for choosing equal sized cubes in their prototypes are most likely grounded in their choice of interaction. They represented arrays as cubes, and the player had to do the physical motion of picking up the cubes to sort them. Picking up big objects is more awkward than using hand-sized objects, and is probably their reason for their design choice. However, my design uses a laser pointer for interaction, and there is no more issue of awkwardly picking up large objects. Using a laser pointer opens up a lot of new options compared to what the other prototypes had, and loses some opportunities in comparison also. One of the reasons behind choosing a laser pointer as interaction mechanism, was that it removes a lot of the distraction involved with having the ability to play around with stuff with virtual hands. Just having hands seem to distract people who has not tried VR before as they are amazed by the feeling of seeing their own hands move in the virtual world. And as the theory presented the previous chapter suggests, distractions are bad when it comes to learning.

Moving on to this project, I want to keep the design, and rather just modify things if a better solution presents itself. 
%For this I wanted to move away from the design the groups from last year had. I thought its focus was not where it should be, as it seemed the focus was more on "which cube has the bigger value?" instead of "what is the next step in the algorithm?" or "which two cubes do I compare next?". The design I went for was also based on cubes to represent the array, but instead of picking them up, and moving them with around with your hands, it is based on selections and actions. Selections happen through pointing with a laser pointer at the array elements and pressing the trigger button, and actions happen through pointing at buttons with the same laser pointer and pushing the trigger button. The idea is that it will be less distracting than picking up blocks. The players might want to start throwing or playing with the cubes rather than what is intended. The point and click interaction hopefully disables these kinds of distracting curiosity. It should, however, be noted that this design was not reached until a later point in the projects, as I had experimented with other forms of interaction. It was also point and click based, but without the action buttons. That design proved to be ill suited for other algorithms than the bubble sort, but was not discovered until the implementation of the insertion sort algorithm started. Also, the environment is very plain and nothing fancy, with the intent behind to save development time, but also keep the focus on the algorithms. And following the theory presented in the previous chapter, the demonstrations and feedback should be in the form of animations and sound.

%Another aspect I thought was important was for the game to easily add new algorithms, and there will therefore be more work to define what is allowed or possible to do, and how to define an algorithm. In other words, there will be more work to get everything working, but there will be less work to add new algorithms once the core is working properly.



%this needs to be here somewhere, not in background
\subsection{Game Engine}
The choice of game engine fell on the decision from the previous project as this project's intentions are to directly improve upon this same prototype. Recreating the previous prototype in another game engine would be a lot of unnecessary work, since the plan is to keep everything and just build on top of the existing prototype, and the other game engine would need to be learned, and probably the programming language the game engine uses as well. This does not fit in with the time schedule of this project. In addition, the gained experience with the game engine from the previous project would shorten further development times. The chosen game engine in the previous project, and therefore this project also, was Unity, because it has a bigger/more active community which will help when problems or confusion arise. Unity is also considered to be better suited for indie developers. Seeing as I am the only one developing this application, I am more comparable to an indie developer rather than a company.

I was already familiar with using unity at this point and did not really need to spend more time on learning the engine. The resourses used for learning this in the previous project was a combination of watching youtube videos, reading the documentation, doing tutorials, and experimenting. The main channels used were \href{https://www.youtube.com/channel/UCLO98KHpNx6JwsdnH04l9yQ}{FusedVR} for VR specifics and \href{https://www.youtube.com/user/Brackeys}{Brackeys} for general Unity things. Experimentation proved to be very effective as it gives hands on experience and a sense of how to work with this technology. Youtube videos are great for getting insight into how certain problems can be solved, and to learn what common pitfalls for beginners are and how to avoid these.
%In order to be able to develop this game or application, Unity had to be learned. This was done through the Unity documentation and their own tutorials, as well as through youtube videos, from channels such as \href{https://www.youtube.com/user/Brackeys}{Brackeys}, and experimentation. Experimentation is very effective as it gives hands on experience and a sense of how to work with this technology. Youtube videos are great for getting insight into how certain problems can be solved, and to learn what common pitfalls for beginners are and how to avoid these. 



\subsection{Summary of Plan}
Something which was planned in the previous project, but not achieved was the environment where the user could navigate to different courses and from there to different parts of these courses. My supervisor had suggested a virtual school ground or university ground and have different courses behind different doors or at different locations in this virtual environment. Despite the prototype only having content within one course, this project would attempt to implement this in some form. However, at a low priority. Expanding and improving functionality should be the main focus of this project. 

The ambition of this project is to add at least one sorting algorithm which is actually used in the real world, and add at least some content within another branch of the Algorithms and Data structures course. This will most likely be either tree-traversing algorithms, or demonstrating some data structures. Improving the existing sorting algorithm scene should also always be attempted. In terms of testing it should be striven after having more test subjects than that which was achieved in the previous project, and also with a higher quality in the testing. 


%A plan was needed before the development could begin. My supervisor had envisioned a sort of virtual university where one could navigate some sort of school or university grounds, and teaching different courses in different areas of this environment. My supervisor also had two groups the previous year which had similar projects where they were using VR to teach sorting algorithms. These were based around the user having to physically sort the cubes but in the way the algorithm dictated it. This idea and these projects would be the foundation for the prototype. 

%An idea, and by that I mean an idea of how the game should be, was also needed before development could begin. My supervisor suggested that the game should be made in a way where it could include many different subjects, and be sort of a virtual university or school. He also suggested that I make the over world or hub look like a university or school, but I thought that it would hinder the inspiration of curiosity, because many people associate schools or class rooms with boredom or other uninspiring emotions. The theory behind game design also suggests that the environment should not be distracting, as the focus should be on the task at hand, or the demonstration. 

%In Oculus Home one can design one's own home space with different interactive and decorative items, and one can visit one's friends homes too. The way this is done, is through breaking a glass orb, with a mini-representation of that home inside the orb(which can be seen in figure \ref{fig:oculussphere}), by throwing it at the floor, and your home is transformed into that of your friend's home. This was the inspiration for my game. I wanted the courses to be glass orbs with a model which could represent the course within them. I thought that this might be simple enough to not distract the user, while at the same time inspire some curiosity through the models inside the orbs. Due to time constraints and manpower, this prototype will only include one course; Algorithms and data structures. Within this course, sorting algorithms are the priority and other algorithms would only be implemented if there was time. 
\begin{comment}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/oculus_home_sphere.jpg}
    \caption{Oculus Home sphere for visiting other people's homes}
    \label{fig:oculussphere}
\end{figure}
\end{comment}



\subsection{Development}
 As already mentioned in the background, Unity supports several programming languages, but mainly C\# and javascript. The choice landed on C\# as this was the language used in the existing prototype. The reason for choosing C\# in the previous project was because the youtube tutorials was focusing on this language, that it seemed to be the easiest one to find help to problems for, as well as a personal preference. To be able to use any VR-kit without writing hardware specific code, the SteamVR Plugin for Unity would be used. To be able to work anywhere, the version control system Git would be used, and it should be hosted on Github, as a public repository. There was no need to use Unity's collaboration tool/version control system, Unity Collab, as there would only be one developer during the extent of this project.
 
 Hosting the project on GitHub in a public repository will enable other developers to further build upon this project, should it turn out to be a good one. And maybe one day it can live up to it's name; UniVRsity! 
 
 \subsection{Architecture}
 The architecture in the previous project, was focused around the game having to be modular, and easily expanded. To do this, sorting algorithms had to be generalized such that the common functionality would not need to be re-implemented, instead only specifics for the new algorithm. The same went for user actions. They were also generalized such that it would be easy to add new actions. This architecture makes it a lot easier to add new algorithms and actions, but it requires more thought into the initial development. The algorithms was generalized fairly well in during the development, however, actions, not so much. Due to the way the algorithms were made, they were completely isolated from the arrays them selves, which meant that actions could not be generally designed. The result was actions just having a type, an enum describing what action it represents, and some integer values representing the position within the array the action should affect. This in turn meant that what the different types action actually does is up to whichever component is handling the action. The positive with this is that the action types can be reused in other scenes, as they have no actual actions linked to them. However, in case it probably would have been smarter to not have the sorting algorithms be disconnected from the array representation, and therefor the actions separated from them. 
 
 This project does not intend to change the architecture. It should still focus on being modular, as this makes it easier for other developers to extend the it and improve upon it. Having the prototype keep evolving and eventually encompassing a plethora of courses is kind of the idea or hope here.
 %As far as architecture for the prototype goes, it was more or less just a rough idea in the beginning and evolved as the development progressed. Another aspect I thought was important was for the game to easily add new algorithms, and there will therefore be more work to define what is allowed or possible to do, and how to define an algorithm. In other words, there will be more work to get everything working, but there will be less work to add new algorithms once the core is working properly.

\subsection{Testing}
%The testing in the previous project was very rushed and therefore poorly done. The test subjects were just thrown into the testing with little or no knowledge of what they were testing and what they should do. 
% --- From the spez proj: For testing the prototype, I would use a System Usability Scale. The optimal testers would be people who are currently taking the course Algorithms and data structures and has no experience with VR. This test will give an indication of weather or not the prototype is intuitive and feels natural to use. These same test subjects will also be encouraged to give feedback on any part of the prototype to help me understand what could be done better, seen from a perspective of "fresh eyes". 

The testing in this project will be fairly similar to the form of testing performed in the previous project, whose form was briefly touched upon in the Previous Work section.  This time there will be a short explanation before the testing starts about what the game is, and its intentions. It will give the testers some context in the form of what they can expect in terms of genre and setting. After the introduction of the game, the testers will play the game. No one will give guidance to the testers unless they explicitly ask for help. If a tester asks for help, it is a sign that some part of the game is not intuitive or something should be better explained within the game. The testers will be informed of this, to increase the threshold for asking for help. After the testers feel they have done enough, they will be asked to fill out a form. This form will contain a section regarding some background information of the tester, a part with the standard SUS questions for getting a usability score, and some general feedback regarding the game and their experience with it. The targets for this testing will be people who has taken or is taking the Algorithms and data structures course, as well as people who has not taken the course but has some experience and knowledge of programming. The level of VR experience a tester has is not of much importance, though a varied spectrum could be nice. This would open up the possibility to check for a connection between previous experience with VR and their understanding of the prototype. As already mentioned the previous project was only able to perform the testing with five people. This time around, the aim is to at least perform tests with double the amount of people.
%When the coding in Unity started, I started with only the bubble sort algorithm in mind. This was a mistake, as this led to having to redo my design at least two times, and also had to redo the core of the sorting algorithms a couple of times as well. This was a huge loss of time, but I believe the core is now pretty sturdy and allows for easy addition of other sorting algorithms. Another big time loss occurred due to an update in the SteamVR Plugin. The development started when it was in version 1, and in version 2, which was launched at the end of September, they had redone the whole interaction system, which meant the interaction system in my game also had to be redone. It also took some time to figure out how this new interaction system worked.



