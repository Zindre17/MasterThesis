%denne delen skal forklare hvordan spillet har blitt implementert og hvordan teorien har blitt utnyttet
\section{Method}
This section will present how the prototype was planned and reasoning behind decisions made, as well as which features and functionality should be implemented in Unity.

\subsection{The Plan}


\subsection{Previous Work}
%say something about what changed from the prev project to this
As already stated, this project is a continuation of another project. The prototype developed in that project consisted of a single scene, which was for teaching sorting algorithms. This scene had only implemented bubble sort and insertion sort at the time. \href{https://youtu.be/7m7B7zJ4KIQ}{Click here} to see a video of the functionality and contents of the first prototype. The interaction was purely through pointing with a laser in the right hand and pressing the trigger when pointing at objects which were interactive. However, this laser pointer was based on the mesh of a gun, and it confused the users, as it suggested to them that they had to defend themselves from something within the game. This could be improved upon in this chapter.

%this needs to be here somewhere, not in background
\subsection{Game Engine}
The choice of game engine fell on the decision from the previous project as this projects intentions are to directly improve upon this same prototype. Recreating the previous prototype in another engine would be a lot of work, because I would need to learn a new engine and such. As I had also gained experience with the game engine from the previous project, this would shorten further development times. The chosen game engine was Unity, because it has a bigger/more active community which will help when problems or confusion arise. Unity is also considered to be better suited for indie developers. Seeing as I am the only one developing this application, I am more comparable to an indie developer rather than a company.

I was already familiar with using unity at this point and did not really need to spend more time on learning the engine. The resourses used for learning this in the previous project was a combination of watching youtube videos, reading the documentation, doing tutorials, and experimenting. The main channel used were \href{https://www.youtube.com/channel/UCLO98KHpNx6JwsdnH04l9yQ}{FusedVR} for VR specifics and \href{https://www.youtube.com/user/Brackeys}{Brackeys} for general Unity things. Experimentation proved to be very effective as it gives hands on experience and a sense of how to work with this technology. Youtube videos are great for getting insight into how certain problems can be solved, and to learn what common pitfalls for beginners are and how to avoid these.
%In order to be able to develop this game or application, Unity had to be learned. This was done through the Unity documentation and their own tutorials, as well as through youtube videos, from channels such as \href{https://www.youtube.com/user/Brackeys}{Brackeys}, and experimentation. Experimentation is very effective as it gives hands on experience and a sense of how to work with this technology. Youtube videos are great for getting insight into how certain problems can be solved, and to learn what common pitfalls for beginners are and how to avoid these. 

\subsection{Continuation}
Something which was planned in the previous project, but not achieved was the environment where the user could navigate to different courses and from there to different parts of these courses. My supervisor had suggested a virtual school ground or university ground and have different courses behind different doors or at different locations in this virtual environment. Despite the prototype only having content within one course. This project would again try to implement this in some form. However, at a low priority. Expanding and improving functionality should be the main focus of this project. 

\subsection{Ambition}
The ambition of this project is to add at least one sorting algorithm which is actually used in the real world, and add at least some content within another branch of the Algorithms and Data structures course. This will most likely be either tree-traversing algorithms, or demonstrating some data structures. Improving the existing sorting algorithm scene should also always be attempted. In terms of testing it should be striven after having more test subjects than that which was achieved in the previous project, and also with a higher quality in the testing. 

\subsection{Testing}
The testing in the previous project was very rushed and therefore poorly done. The test subjects were just thrown into the testing with little or no knowledge of what they were testing and what they should do. This time a series of tasks should be planned and during the testing the subjects should be prompted to complete each task. When they think they are done with the task, they should receive the next one, and so forth until all tasks are completed or they decide that they want to end the test early. An explanation of what it is they are testing should also be provided before the actual testing starts. The ideal background for the test subjects should be students currently taking the course, and the next best thing are students which has already completed or attempted the course prior to the testing.
%A plan was needed before the development could begin. My supervisor had envisioned a sort of virtual university where one could navigate some sort of school or university grounds, and teaching different courses in different areas of this environment. My supervisor also had two groups the previous year which had similar projects where they were using VR to teach sorting algorithms. These were based around the user having to physically sort the cubes but in the way the algorithm dictated it. This idea and these projects would be the foundation for the prototype. 

%An idea, and by that I mean an idea of how the game should be, was also needed before development could begin. My supervisor suggested that the game should be made in a way where it could include many different subjects, and be sort of a virtual university or school. He also suggested that I make the over world or hub look like a university or school, but I thought that it would hinder the inspiration of curiosity, because many people associate schools or class rooms with boredom or other uninspiring emotions. The theory behind game design also suggests that the environment should not be distracting, as the focus should be on the task at hand, or the demonstration. 

%In Oculus Home one can design one's own home space with different interactive and decorative items, and one can visit one's friends homes too. The way this is done, is through breaking a glass orb, with a mini-representation of that home inside the orb(which can be seen in figure \ref{fig:oculussphere}), by throwing it at the floor, and your home is transformed into that of your friend's home. This was the inspiration for my game. I wanted the courses to be glass orbs with a model which could represent the course within them. I thought that this might be simple enough to not distract the user, while at the same time inspire some curiosity through the models inside the orbs. Due to time constraints and manpower, this prototype will only include one course; Algorithms and data structures. Within this course, sorting algorithms are the priority and other algorithms would only be implemented if there was time. 
\begin{comment}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/oculus_home_sphere.jpg}
    \caption{Oculus Home sphere for visiting other people's homes}
    \label{fig:oculussphere}
\end{figure}
\end{comment}

\subsection{Design}
That is just one part of the design. The part where the learning happens, also needs to be designed. For this I wanted to move away from the design the groups from last year had. I thought its focus was not where it should be, as it seemed the focus was more on "which cube has the bigger value?" instead of "what is the next step in the algorithm?" or "which two cubes do I compare next?". The design I went for was also based on cubes to represent the array, but instead of picking them up, and moving them with around with your hands, it is based on selections and actions. Selections happen through pointing with a laser pointer at the array elements and pressing the trigger button, and actions happen through pointing at buttons with the same laser pointer and pushing the trigger button. The idea is that it will be less distracting than picking up blocks. The players might want to start throwing or playing with the cubes rather than what is intended. The point and click interaction hopefully disables these kinds of distracting curiosity. It should, however, be noted that this design was not reached until a later point in the projects, as I had experimented with other forms of interaction. It was also point and click based, but without the action buttons. That design proved to be ill suited for other algorithms than the bubble sort, but was not discovered until the implementation of the insertion sort algorithm started. Also, the environment is very plain and nothing fancy, with the intent behind to save development time, but also keep the focus on the algorithms. And following the theory presented in the previous chapter, the demonstrations and feedback should be in the form of animations and sound.

Another aspect I thought was important was for the game to easily add new algorithms, and there will therefore be more work to define what is allowed or possible to do, and how to define an algorithm. In other words, there will be more work to get everything working, but there will be less work to add new algorithms once the core is working properly.

For testing the prototype, I would use a System Usability Scale. The optimal testers would be people who are currently taking the course Algorithms and data structures and has no experience with VR. This test will give an indication of weather or not the prototype is intuitive and feels natural to use. These same test subjects will also be encouraged to give feedback on any part of the prototype to help me understand what could be done better, seen from a perspective of "fresh eyes". 

\subsection{Development}
 C\# was decided as the language to use with unity in this project, because the youtube tutorials was focusing on this language, that it seemed to be the easiest one to find help to problems for, as well as a personal preference. To be able to use any VR-kit without writing hardware specific code, the SteamVR Plugin for Unity would be used. To be able to work anywhere, the version control system Git would be used, and it should be hosted on Github, as a public repository. There was no need to use Unity's collaboration tool/version control system, Unity Collab, as there would only be one developer during the extent of this project.
 
 \subsection{Architecture}
 As far as architecture for the prototype goes, it was more or less just a rough idea in the beginning and evolved as the development progressed. 

%When the coding in Unity started, I started with only the bubble sort algorithm in mind. This was a mistake, as this led to having to redo my design at least two times, and also had to redo the core of the sorting algorithms a couple of times as well. This was a huge loss of time, but I believe the core is now pretty sturdy and allows for easy addition of other sorting algorithms. Another big time loss occurred due to an update in the SteamVR Plugin. The development started when it was in version 1, and in version 2, which was launched at the end of September, they had redone the whole interaction system, which meant the interaction system in my game also had to be redone. It also took some time to figure out how this new interaction system worked.



