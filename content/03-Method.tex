%denne delen skal forklare hvordan spillet har blitt implementert og hvordan teorien har blitt utnyttet
\section{Methodology}

This section will present how the prototype was planned, the different choices made in regards to how the development should be done, and also how the testing should be performed. 

\subsection{General Plan}
The plan going into this project was to continue the development of the prototype developed in the previous project. Making improvements and adding new features to it, and then test it again to see if it was actually improved. As far as design goes there will not be any major changes, unless something which forces this occurs. There will however be additions to it, and these additions will try to achieve a similar style. This is to be consistent with how things work, not causing unnecessary confusion in the players. The planning of the expansion of content and making improvements will happen in iterations. Come up with a next step(a general idea, no specifics), figure out how to implement this idea, implement it, then from there figure out where to go next. The next step for each iteration would mostly come from the meetings with the supervisor.  

Coming from the previous project the structure of the prototype was just a single scene. However, the plan for a finished product looked something like that which can be seen in  \autoref{fig:plan}. The question marks represent any number of courses or topics, and the structure is hierarchical. The overworld is at the top of the hierarchy and form there the player can navigate to any course hub. The course hubs are the next level of the hierarchy where the player can either navigate back to the overworld, or to any topic within the course. The topics are the lowest level in the hierarchy, and the player can only navigate back to its course hub from there. This hierarchy will be the guide when adding new content in this project.


\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/Plan.png}
\caption{The idea of how the scenes in the final product should be arranged. The question marks can be any number of boxes.}
\label{fig:plan}
\end{figure}



\subsubsection{Iteration 1}
The goal for the first iteration was to add another topic from the course Algorithms and data structures. The topic chosen was data structures, despite the previous project having some ideas around tree traversing algorithms. The reason for this, was to better represent the content of the course. It is not only about algorithms. Another idea which were considered was to start adding another course like Machine learning. This would imply a scene structure like the one seen in \autoref{fig:plan_potential}. However, this was discarded for the time being, and the structure would instead look like the one presented in \autoref{fig:plan_final}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/potential_further_dev.png}
\caption{How the scenes in the game would be arranged, if the machine learning course was added instead of the data structure topic.}
\label{fig:plan_potential}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/actual_result.png}
\caption{The plan for how the scenes in the game would be arranged, after the first iteration}
\label{fig:plan_final}
\end{figure}

\subsubsection{Iteration 2}
The next iteration after the initial data structure scene was added, was to go back to the sorting algorithm scene and add a better and more commonly used algorithm to the mix. The algorithm chosen was quick sort, as it fits these criteria.

\subsubsection{Iteration 3}
In the third iteration, the idea was to add some form of use case to each of the data structures. The idea behind that idea was to show the player how this data structure could be used in a real life scenario. As the data structures added in the previous iteration was a stack and a queue, and the supervisor teaching visual computations the decision for use case landed on an image region growing algorithm. This algorithm need to keep track of which pixels to explore, which works with both a stack and a queue, but will behave different in how the pattern grows.

\subsubsection{Iteration 4}
Seeing as the overworld, course hubs, and the navigation between them was still not implemented, it was time to do this. This was planned already back in the previous project but not achieved in the duration of it, and it was long overdue to get started on this. It would still be arranged like the figure from iteration 1,  \autoref{fig:plan_final}. My supervisor had an idea of making the overworld look similar to a school ground or university ground. However, due to time constraints, the looks of it was not the priority. The priority was getting the functionality down. Considering that I have no experience in creating 3D models, textures, or other forms of visuals, the results would probably be sub-par and it would cost me a lot of time. 

\subsubsection{Iteration 5}
After the overworld and navigation was added, I wanted to add the merge sort algorithm. Though this required a lot of rework to the sorting scene in the state it was at, at the time. Merge sort is different to the other three sorting algorithms in that it creates new arrays in the process.  

\subsubsection{Iteration 6} \label{sec:It6}
This time I had realized that I had forgotten to improve things which were commented on or discovered during the testing in the previous project. I had been too focused on adding new features and improving stability and architecture, and forgotten probably the most important part; improving the usability. This iteration would therefore consist of making a lot of improvements in terms of usability and thoroughly testing the application to find and squash bugs before the testing started. 

\subsection{Development}
The choice of game engine and programming language fell on the decision from the previous project, namely Unity and C\#, as this project's intentions are to directly improve upon this same prototype. Recreating the previous prototype in another game engine would be a lot of unnecessary work, since the plan is to keep everything and just build on top of the existing prototype, and the other game engine would need to be learned, and probably the programming language the game engine uses as well. This does not fit in with the time schedule of this project. In addition, the gained experience with the game engine from the previous project would shorten further development times. In other words, I was already familiar with using Unity and C\# at this point and did not really need to spend more time on learning the engine. This project would continue to work on the same public repository on Github as in the previous project. 

This project does not intend to alter the architecture of the existing prototype. It should still focus on being modular, as this makes it easier for other developers to extend it and improve upon it. Having the prototype keep evolving and eventually encompassing a plethora of courses is kind of the idea or hope here. However, considering the time constraint, making things work is more important than having a good architecture. At least in the short term scenario. 

\subsubsection{Requirements}
Following is a list of functional requirements for the project, sorted by the scenes. Non-functional requirements were not set, except for keeping the prototype performance efficient.

\subsubsection*{Common to all scenes}
\begin{itemize}
    \item Player - A camera and controller reflecting the physical orientation and position of the player hand his/her hands/controllers. Also has a laser pointer in the right hand for interacting with the world
    \item Show outline on interactive objects when hovering over with the laser pointer
    \item Interact with interactive objects by pressing the trigger button on the controller with the laser pointer while pointing at it
    \item Buttons - Interactive object
    \item Show which buttons are disabled by changing their color, and the color of the outline when hover over
\end{itemize}

\subsubsection*{Over world}
\begin{itemize}
    \item Show available courses as different buttons
    \item Course buttons - Loads the button's course
    \begin{itemize}
        \item Algorithms and Data Structures
    \end{itemize}
\end{itemize}

\subsubsection*{Algorithms and Data Structures}
\textbf{Course hub(entry point):}
\begin{itemize}
    \item Show available topics as buttons
    \item \textbf{Topic buttons} - Loads the button's topic
    \begin{itemize}
        \item Data structures
        \item Sorting algorithms
    \end{itemize}
    \item Back navigation button - Go back to the over world
\end{itemize}

\textbf{Data structures:}
\begin{itemize}
    \item \textbf{Play mode} - Learn how the selected structure works
    \begin{itemize}
        \item Show available structures as buttons
        \item \textbf{Structure buttons} - Go to play mode for selected structure
        \begin{itemize}
            \item Stack
            \item Queue
        \end{itemize}
        \item \textbf{Stack and Queue} - Same play mode
        \begin{itemize}
            \item Show a representation of the data structure
            \item Push/Enqueue button - Animate how the structure handles addition of data
            \item Pop/Dequeue button - Animate how the structure handles removal/retrieval of data
            \item Use case button - Go to use case mode for this structure
            \item Back navigation button - Go back to course hub
            \item Show explanation of each button
            \item Show error message when doing an illegal action containing the error (Overflow/Underflow) and when it occurs
        \end{itemize}
    \end{itemize}
    \item \textbf{Use case mode} - See how the selected structure can be used in a real life scenario
    \begin{itemize}
        \item \textbf{Stack and Queue} - Same use case: Image region growing
        \begin{itemize}
            \item Back navigation button - Go back to play mode for this structure
            \item Show a description of what this use case is when entering the use case mode. Press the button on this panel to hide it and start the algorithm.
            \item Show a black and white image with random pattern. Each pixel is an interactive object.
            \item Pixel(interactive object) - Select (show a border color to indicate that it is selected)
            \item Show a representation of the data structure selected before entering use case mode
            \item Show a representation of the the item from the data structure is currently being read/used ("Next" as it points to the next pixel to check)
            \item Show a representation of the internal state of the algorithm (Pattern so far, visited pixels, which pixel is next, etc...)
            \item Show an explanation of the color coding in the representation of the algorithm
            \item \textbf{Action buttons}
            \begin{itemize}
                \item Push/Enqueue - Animate addition of the selected Pixel to the data structure
                \item Pop/Dequeue - Animate removal of next pixel from the data structure and into the "Next" position. 
                \item Check - Animate the checking(whether it is or is not part of the pattern) of the pixel.
            \end{itemize}
            \item \textbf{Algorithm interaction buttons}
            \begin{itemize}
                \item Demo(toggle button) - Start/stop the demonstration of the algorithm. The demonstration animates how the algorithm works step by step.
                \item Prev - Undo the last step in the algorithm(animate)
                \item Next - Do the next step in the algorithm(animate)
            \end{itemize}
            \item An attempt at doing an action the algorithm does not expect, it will not perform the action and instead hint at the expected action by blinking the required elements and action button a few times. 
            \item Data items popped or dequeued into "Next" will fire a laser at the pixel it represents. To indicate which pixel should be checked next
        \end{itemize}{}
    \end{itemize}
\end{itemize}

\textbf{Sorting Algorithms}
\begin{itemize}
    \item Back navigation button - Go back to course hub
    \item Show available sorting algorithms as buttons
    \item Show the array as a horizontal set of cuboids(array elements) on top of another cuboid(array stand or representation of the memory location). The elements has a height relative to their value: high value means a tall cuboid, and a low value means a short cuboid.  
    \item Both the array and the the elements are interactive
    \item Show a Cube representing the storage (where array elements can be temporarily stored)
    \item Show a representation of the internal state of the algorithm
    \item Show pseudo code for the selected algorithm
    \item \textbf{Sorting algorithm buttons} - Generates a new random array and changes to this algorithm
    \begin{itemize}
        \item Bubble sort
        \item Insertion sort
        \item Quick sort
        \item Merge sort
    \end{itemize}
    \item \textbf{Algorithm interaction buttons}
    \begin{itemize}
        \item Demo(toggle button) - Start/stop demonstrating the algorithm. The demonstration shows the algorithm step by step in the correct order and explains what it is doing.
        \item Prev - Undo the last step in the algorithm(animate)
        \item Next - Do the next step in the algorithm(animate)
        \item New array - Generate a new random array
        \item Restart - Resets the algorithm, and array back to start    
    \end{itemize}
    \item \textbf{Action buttons}
    \begin{itemize}
        \item Compare - Compare the value of two elements
        \item Swap - Swap the values/position of one or two element(s)
        \item Store - Clone one of the elements in the array to the storage
        \item Copy to - Two step action: Copy selected element value into the next selection (limitations: can not copy to storage, use Store instead)
        \item Pivot - Sets the selected element as a pivot
        \item Split - Splits the selected array in two halves
        \item Merge - Start the merge of two arrays
    \end{itemize}
    \item An attempt at doing an action the algorithm does not expect, it will not perform the action and instead hint at the expected action by blinking the required elements and action button a few times. 
    
\end{itemize}

\subsubsection{Implementation}
This part will talk a bit about how the major parts in the game was coded, how they work, and how they interact with each other. The different pieces will be classified as either one of these: 
\begin{itemize}
    \item A component - A C\# class inheriting from MonoBehaviour.
    \item A prefab - A template for a game object which can be used to spawn predefined game objects at run-time or for speeding up the scene building process.
    \item A class - A C\# class.
    \item An interface - A C\# interface.
\end{itemize}

Pieces common on for all scenes:
\begin{itemize}
    \item \textbf{LaserPointerPlayer} 
    \begin{itemize}
        \item[] The ``LaserPointerPlayer'' prefab was a modified version of the ``Player'' prefab which is shipped out of the box with Steam VR. The ``Player'' prefab controls the tracking of the controllers and the HMD. The modified version removed the hand models, and their gesture simulation as this is not needed for the interaction within the game. Instead the hand models were replaced by spheres and attached to the right hand was a laser pointer which is used for interaction. Along with this laser pointer model, a component(``LaserPointer'') was added to control this model. 
    \end{itemize}
    
%fallback
    \item \textbf{\_FallbackGame}
    \begin{itemize}
        \item[] ``\_FallbackGame'' is a prefab, and it came to be after a bug which was found late in the development. It was not found until very late in the process as the scenes were usually only tested individually, and not after transitioning from one to the other. As it turned out the player prefab was not destroyed on scene change, and every scene had one of these player prefabs, which meant there would be several player objects in the scene after the first scene was left. This was not obvious as most of the scenes had the player object in the exact same spot and they were just overlapping each other. However, when transitioning from a scene were this object was in another position than the previous scene, it became very obvious as one could see two laser pointers originating from different spots. The solution to this was to create this ``\_FallbackGame'' prefab. The purpose of this ``\_FallbackGame'' object was to check for a player(a ``LaserPointerPlayer'' prefab) and if there was none, instantiate one, else, destroy itself. This made it possible to start the game from any scene and still visit other scenes without getting multiple players, and without only having a player in one of the scenes. This was the initial function of this prefab, but since there would only ever be one of these objects, the opportunity arose to move all other components which were required by all scenes into this same object. Kind of making it into the core of the game, and hence the name ``\_FallbackGame'', where ``Fallback'' comes from the part where it checks whether or not it is needed, and ``Game'' coming from the contents being all the stuff required everywhere within the game. The contents are, excluding the player, the ``EventManager'' and the ``ColorManager'' components, as of the time of writing. 
    \end{itemize}
    
    
%eventmanager
    \item \textbf{EventManager}
    \begin{itemize}
        \item[] The ``EventManager'' is a component which contains every event which could happen in the game, and allows other classes or components to subscribe to these events. The events are set up with delegate types for the different types of events, and matching static events using these delegate types. Having the events be static means that other components does not need a reference to the active ``EventManager'' in order to subscribe to events. Then, all a component need to do in order to subscribe to an event is to define a methos which takes the same parameters as the delegate type of the event, and append that method to the event. Like this: 
        \begin{lstlisting}[language=C]
// Subscribe to event
EventManager.Name_of_event += Name_of_function;

// Unsubscribe from event
EventManager.Name_of_event -= Name_of_function;
        \end{lstlisting} 
        This component also has the responsibility to handle the laser pointer and the interaction with the controllers. It has a reference to the ``LaserPointer'', a component attached to the ``LaserPointerPlayer'' object, which gives the ``EventManager'' information about the position and orientation of the pointer. Every frame it then uses this information to fire a ray cast from the tip of the laser pointer in the direction it faces. After that it uses the result of the ray cast in order to check whether it is pointing at an interactive object. If it is pointing at an interactive object, it will trigger the hover effect of that object, and if the player is also pressing the trigger button while pointing at this interactive object, it will fire the appropriate event according to the type of interactive object. 
    \end{itemize}
    
%colormanager
    \item \textbf{ColorManager}
    \begin{itemize}
        \item[] ``ColorManager'' is a simple component. All it does is provide a way to define colors in the Unity inspector and expose a static instance of this object. This public static object reference makes the defined colors available anywhere within the scene without having to instantiate an instance of this class or having a reference to one. It is also set up to have a Singleton architecture, meaning that there will only ever be a maximum of one instance of this class at any given time. 
    \end{itemize}
    
%uibutton
    \item \textbf{UIButton}
    \begin{itemize}
        \item[] ``UIButton'' is an abstract component. The ``UIButton'' component's function is to provide an animation for pressing it, and also give the possibility to add methods to trigger when it is pressed. Methods can either be added through code, or through the inspector in Unity. To achieve this possibility an event class inheriting from the generic ``UnityEvent\textless T\textgreater'' class was created, internally in the ``UIButton'' class. The ``T'' can be replaced with whatever type you want to pass to this event. In this case:
        \begin{lstlisting}[language=C]
[Serializable]
public class ButtonEvent: UnityEvent<UIButton> { }

public ButtonEvent onButtonPressed;
        \end{lstlisting}
        As we can see, the ``ButtonEvent'' inherits from ``UnityEvent\textless UIButton\textgreater''. This means that methods subscribed to this event will get a ``UIButton'' instance passed to them. This was to ensure that any property or functionality of any sub-classes of ``UIButton'' could be used if needed. The ``UIButton'' class itself, however, contains no useful information to be used by the subscribed method. The ``[Serializable]'' part along with the public ``ButtonEvent'' variable, enables the subscriptions to be done trough the Unity inspector. Calling all the subscribed methods is just a matter of calling the ``Invoke'' method and passing an instance of the required type along with it. like this:
        \begin{lstlisting}[language=C]
// "this" is in this case the UIButton instance
onButtonPressed.Invoke(this);
        \end{lstlisting}
        
        Sub-classes of ``UIButton'' are ``MenuButton'', ``ActionButton'', and ``ModeButton''. ``MenuButton'' just inherits from ``UIButton'' without altering or extending it in any way. The only reason it exists is to have a component name which indicates what kind of button this is.``ActionButton'' is the most extended version. It adds functionality for blinking the buttons, as to hint which action to perform next, and it allows for action buttons to be multi-stepped. This means that when an action button which is set up as a multi-step action is pressed, it will enter an ``in progress'' state. And to complete this action, the next selection will be registered as the continuation of this action. ``ModeButton'' has only one addition, which is expose a field which can be used to specify what mode this button should trigger.  
        \end{itemize}    
        
%SceneChanger
    \item \textbf{SceneChanger}
    \begin{itemize}
        \item[] ``SceneChanger'' is an abstract component. All it does is provide a method for transitioning to another scene by fading to black and then fading back in to the new scene. To do this it utilizes the ``SteamVR\_LoadLevel.Begin()'' method, provided by the SteamVR plugin, passing the name of the scene to load and the duration of the fade as parameters.
        
        Current sub-classes are: ``MainSceneChanger'', and ``AlgDatSceneChanger''.
    \end{itemize}
    
    \item \textbf{PlayerPositioner}
    \begin{itemize}
        \item[] ``PlayerPositioner'' is a component. Its function is to find the player and position it at the location of the game object this component is attached to, when the scene starts. This means that the ``\_FallbackPlayer'' prefab can be placed anywhere in the scene as long as there a ``PlayerPositioner'' component at the position where the player should be. 
    \end{itemize}
    
    
\end{itemize}

The overworld and course hub for ``Algorithms and data structures'' does not contain any pieces which are exclusive to their scenes. They only use what they need from the common components listed above. The sorting algorithms scene and data structures scene on the other hand, does have exclusive parts. The data structures scene is split into two modes; play mode and use case mode, and these are the important parts from both modes:

\begin{itemize}
    \item \textbf{Stage}
    \begin{itemize}
        \item[] The ``Stage'' component exposes methods for switching between the play- and use case modes, and makes sure both these modes are updated with the correct data structure to use(the chosen structure). 
    \end{itemize}
    
    \item \textbf{DStack}
    \begin{itemize}
        \item[] ``DStack'' is a component, and the naming of this is not very representative of what it does. It actually contains all the logic for both the stack and the queue. Originally it was split into two but realizing that they were very similar and that only a boolean value was needed to tell them apart, they were merged, and the ``DStack'' was arbitrarily chosen over the ``DQueue'', and it was never renamed to fit its contents better. Its contents are definitions for animations for both the stack and the queue in regards to adding and removing data, exposes methods for triggering these animations, keeps references to a few positions it uses for animations, and it keeps track of how many data items it holds and can hold. 
    \end{itemize}

    \item \textbf{Play}
    \begin{itemize}
        \item[] ``Play'' is a component, which sets the ``DStack'' in the correct mode, based on the selected data structure. It also makes sure all of the game objects within the play mode is shown when in play mode, and hidden when in use case mode. 
    \end{itemize}
    
%RegionGrowingAlgorithm
    \item \textbf{RegionGrowAlgorithm}
    \begin{itemize}
        \item[] The class ``RegionGrowAlgorithm'' generates a list of actions needed to be performed to extract the connected region/pattern in the image based on a seed point within the image. It exposes methods for retrieving these actions and this enables the game to perform the algorithm one step at a time. 
    \end{itemize}

%ImageHandler
    \item \textbf{ImageHandler}
    \begin{itemize}
        \item[] The ``ImageHandler'' component, is responsible for creating a two dimensional array of ``Pixel'' prefabs to represent an image. It also generates a random pattern in this image, and exposes methods for retrieving individual pixels and for selecting them. The ``Pixel'' prefab contains a cube mesh and the ``Pixel'' component, which has a boolean value which controls weather this pixel is black or white. The ``Pixel'' component is one of the components the ``EventHandler'' component looks for when pointing the laser pointer, making pixels selectable/interactive. 
    \end{itemize}
    
%DataStructure
    \item \textbf{DataStructure}
    \begin{itemize}
        \item[] The ``DataStructure'' component does alot of the same as the ``DStack'' component, except it is modified to make the animations fit this part of the scene and with a few additions. 
    \end{itemize}
    
%ImageRep
    \item \textbf{ImageRep}
    \begin{itemize}
        \item[] ``ImageRep'' is a component which generates a representation of the state within the algorithm. It does so by generating a miniature version of the image, but without the pattern. The colors of each pixel represents the state of it, and it can be one of the following: unvisited(default), visited, seed, next, added to stack/queue, or part of patter. It also shows a legend of all the colors and their meaning.
    \end{itemize}
    
%PatternRep
    \item \textbf{PatternRep}
    \begin{itemize}
        \item[] The ``PatterRep'' component is similar to the ``ImageRep'' but in contrast only has two states: part of patter, or not. It shows which pixels are confirmed as part of a region or pattern this far in the algorithm.
    \end{itemize}

%usecase
    \item \textbf{UseCase}
    \begin{itemize}
        \item[] ``UseCase'' is a component, and it does the opposite of the ``Play'' component, by hiding its belonging game objects when in play mode, and showing them when in use case mode. However, it also contains a lot more. It has references to all the parts in this part of the scene, all mentioned above, and it contains the logic for how and when the user can interact with them. 
    \end{itemize}
\end{itemize}

The sorting algorithms scene is the most complex scene and these are the most important pieces:

\begin{itemize}
    \item \textbf{SortingManager}
    \begin{itemize}
        \item[] The SortingManager is a component which basically glues everything together, and keeps track of and handles most of the logic for the flow of the game. Basically the big boss commanding all its minions. This class is however dependent on a lot of other smaller components. This class does not know \textit{how} to do things, only \textit{what} to do. Therefore it must have references to the components which actually know \textit{how} to perform these actions or handle specific events. It does not only know \textit{what} to do, it also knows \textit{when this is allowed} to do. In other words, it keeps track of a bunch of states and when it is notified of some interaction happening, it will decide whether or not this is legal and act accordingly. 
        Some references it keeps are :
        \begin{itemize}
            \item SortingAlgorithm - An algorithm which the array should be sorted after
            \item Arrays - Keeps track of all the arrays, and the logic for interacting with them
            \item Comparison - Handles compare actions
            \item TitleManager - Updates the title of the room to the current algorithm
            \item StateManager - Shows the updated state of the algorithms internals
            \item ActionManager - Handles the state of the Action buttons (active or not)
            \item AlgoControlManager - Handles the state of the buttons controlling the algorithm(Demo, prev, and next)
            \item MessagesManager - Shows messages to the player about things that are happening
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Selectable}
    \begin{itemize}
        \item[] ``Selectable'' is an abstract component, which is the parent class for all selectable game objects in this scene except for the buttons. The selectable class contains everything which is common for all these objects, namely that they can be selected, and a few other things. Current sub-classes are the ``ArrayManager'', ``SortingElement'', ``EmptyElement'', and ``PartialArray'' components. These can all be selected and performed actions on. 
    \end{itemize}
    
    \item \textbf{SortingElement}
    \begin{itemize}
        \item[] ``SortingElement'' is both a prefab, and component, which is also attached to this prefab. The prefab contains a cube mesh to represent the array element, text to show which element this is, and a ``SortingElement'' component. This component contains some information about the element which is useful or needed by other components when performing actions on these. It is also as mentioned a sub-class of ``Selectable''.
    \end{itemize}
    
    
    \item \textbf{ArrayManager}
    \begin{itemize}
        \item[] The ``ArrayManager'' component used to be the main component in terms of keeping track of all the ``SortingElement'' game objects, animating their positions and sizes, and expose methods for performing these actions. It is now reduced to only keeping track of its belonging elements, and exposes methods for getting these elements. The new main component for the arrays and elements now, is ``Arrays''.
    \end{itemize}
    
    \item \textbf{Arrays}
    \begin{itemize}
        \item[]``Arrays'' is a component. It handles the logic of how the different actions affect the array(s), and last but not least which array it should perform the action on. In the beginning this component contained all the animations for the arrays and array elements too, but it got really big and I wanted to separate the animations of the different actions with the logic behind them. And hence the ``ElementAnimator'' was born. However, it turned out some of the logic still had to happen within the animation and are therefore not completely separate after all... Nevertheless, it turned out to be helpful in terms of navigating the code, when all the animation logic was in one file, while most of the logic was in the other.

        The ``Arrays'' component is also an evolution from ``ArrayManager''. As I added the merge sort algorithm there was need for more than one array, and therefore the ArrayManager which was doing everything for the original array was not sufficient any more. Hence the ``Arrays'' component was created. It stole the logic from ``ArrayManager'' and added some more to handle several arrays. The ``ArrayManager'' was cut down to only keep track of its elements. 
        So the history went like this:
        \begin{itemize}
            \item ArrayManager
            \item ArrayManager and Arrays
            \item ArrayManager, Arrays and ElementAnimator
        \end{itemize}
    \end{itemize}
    
    \item \textbf{PartialArray and CombinedArray}
    \begin{itemize}
        \item[] The ``PartialArray'' and ``CombinedArray'' components, were added alongside ``Arrays'' during the implementation of merge sort. These contain a reference to a prefab which lets them spawn a new array cuboid with its own elements. And they are used when splitting an array in two halves, and merging them back together. They contain similar logic to ``ArrayManager''.
    \end{itemize}
    
    \item \textbf{SortingAlgorithm}
    \begin{itemize}
        \item[] ``SortingAlgorithm'' is an abstract class, and defines a set of abstract methods which all sub-classes needs to implement, a set of virtual methods which already has a definition but can be overridden by the sub-classes, and a set of defined methods which will always be the same for all sub-classes. Having this abstract class makes adding new algorithms a lot faster, as a lot of the code for each algorithm would be the same. It also makes the addition of new algorithms less error prone, as the core is already there for each algorithm and only what is specific for the algorithm needs to be added. The abstract methods are the ``GenerateActions'' method, and the ``CheckForFocusChange'' method. ``GenerateActions'' return Void and takes no parameters. It is called in the constructor and the intention of this method is to add all the ``GameActions'' needed to sort the array in the correct order and with the correct indexes to the actions list, as well as add an equal number of states to the states list to let the user peek inside the state of the algorithm. The ``CheckForFocusChange'' method should trigger an event in the ``EventManager'' when the algorithm reaches a state where there is a change in which elements are in focus.
 
    \end{itemize}
\end{itemize}


A lot of the components explained above mention animations, and that they keep definitions of animations, and ways to trigger them. However, none explain how they are defined and how they work. The animations were coded, and the way the animations were coded was by using coroutines. Couroutines are a part of the ``UnityEngine'' library, and they work by defining a method with a return type of ``IEnumerator'', and should contain the code for doing the animation, i.e move, rotate, and or scale objects. And to start the defined animation one needs to call the ``StartCoroutine'' method and provide the animation function as a parameter to that function. 
Like this:
\begin{lstlisting}[language=C]
IEnumerator SomeAnimation(){
    float duration = .6f;
    float elapsed = 0f;
    float prevTime = Time.time;
    //This while loop will run one iteration of the loop every frame for .6 seconds. This way of writing the coroutine makes the animation's duration independent of the frame-rate
    while(elapsed < duration){
        // Do something every frame here
        ...
        float time = Time.time;
        elapsed += time - prevTime;
        prevTime = time;
        yield return null;
    }
    //Do something at the end of the animation here
    ...
}

...
// Somewere inside a function which should trigger the SomeAnimation animation
StartCoroutine(SomeAnimation());
\end{lstlisting}

The special part about these coroutines is that is executes code until it reaches a ``yield return ...'' statement, then it will stop executing, and then continue from where it left off at the next frame. There is no limit on the amount of ``yield return ...'' statements a coroutine can have. the value after ``yield return'' can be either null or one of several different types for waiting specific times until resuming execution, like a set amount of time in seconds, or at the end of the frame instead of the beginning of the frame, and so on. 


\subsection{Evaluation}
The evaluation in this project will be fairly similar to the form of evaluation performed in the previous project, whose form was briefly touched upon in the Previous Work section.  This time there will be a short explanation before the evaluation starts about what the game is, and its intentions. It will give the participants some context in the form of what they can expect in terms of genre and setting. After the introduction of the game, they will play the game, or in other words perform a user test. No one will give guidance to them unless they explicitly ask for help. If a participant asks for help, it is a sign that some part of the game is not intuitive or something should be better explained within the game. The participants will be informed of this, to increase the threshold for asking for help. After the participants feel they have done enough, they will be asked to fill out a form. This form will contain a section regarding some background information of the participant, a part with the standard SUS questions for getting a usability score, and some general feedback regarding the game and their experience with it. The targets for this evaluation will be people who has taken or is taking the Algorithms and data structures course, as well as people who has not taken the course but has some experience and knowledge of programming. The level of VR experience a participant has is not of much importance, though a varied spectrum could be nice. This would open up the possibility to check for a connection between previous experience with VR and their understanding of the prototype. As already mentioned the previous project was only able to perform the testing with five people. This time around, the aim is to at least perform tests with double the amount of people.
