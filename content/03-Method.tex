%denne delen skal forklare hvordan spillet har blitt implementert og hvordan teorien har blitt utnyttet
\section{Method}
This section will present how the prototype was planned and reasoning behind decisions made, as well as which features and functionality should be implemented in Unity.

\subsection{General Plan}
The plan going into this project was to continue the development of the prototype developed in the previous project. Making improvements and adding new features to it, and then test it again to see if it actually improved. As far as design goes there will not be any major changes, unless something which forces this occurs. There will however be additions to it, and these additions will try to achieve a similar style. This is to be consistent with how things work, not causing unnecessary confusion in the players. The planning of the expansion of content and making improvements will happen in iterations. Come up with a next step, implement this idea, then from there figure out where to go next. In other words it should happen in iterations, where the planning of each iteration would mostly happen through meeting with the supervisor. 

\subsubsection{Iteration 1}
The goal for the first iteration was found through having a discussion with my supervisor, and the result of this was to add another topic from Algorithms and data structures. The topic chosen was data structures. Another idea which were considered was to start adding another course like Machine learning. However, this was discarded for the time being. 

\subsubsection{Iteration 2}
The next iteration after the initial data structure scene was added, was to go back to the sorting algorithm scene and add a more commonly used algorithm to the mix. The algorithm chosen was quick sort. 

\subsubsection{Iteration 3}
In the third iteration, the idea was to add some form of use case to each of the data structures. The idea behind that idea was to show the player how this data structure could be used in a real life scenario. As the data structures added in the previous iteration was a stack and a queue, and the supervisor teaching visual computations the decision for use case landed on an image region growing algorithm. This algorithm need to keep track of which pixels to explore, which works with both a stack and a queue, but will behave slightly different in how the pattern grows. 

%Moving on to this project, I want to keep the design, and rather just modify things if a better solution presents itself. 

%For this I wanted to move away from the design the groups from last year had. I thought its focus was not where it should be, as it seemed the focus was more on "which cube has the bigger value?" instead of "what is the next step in the algorithm?" or "which two cubes do I compare next?". The design I went for was also based on cubes to represent the array, but instead of picking them up, and moving them with around with your hands, it is based on selections and actions. Selections happen through pointing with a laser pointer at the array elements and pressing the trigger button, and actions happen through pointing at buttons with the same laser pointer and pushing the trigger button. The idea is that it will be less distracting than picking up blocks. The players might want to start throwing or playing with the cubes rather than what is intended. The point and click interaction hopefully disables these kinds of distracting curiosity. It should, however, be noted that this design was not reached until a later point in the projects, as I had experimented with other forms of interaction. It was also point and click based, but without the action buttons. That design proved to be ill suited for other algorithms than the bubble sort, but was not discovered until the implementation of the insertion sort algorithm started. Also, the environment is very plain and nothing fancy, with the intent behind to save development time, but also keep the focus on the algorithms. And following the theory presented in the previous chapter, the demonstrations and feedback should be in the form of animations and sound.

%Another aspect I thought was important was for the game to easily add new algorithms, and there will therefore be more work to define what is allowed or possible to do, and how to define an algorithm. In other words, there will be more work to get everything working, but there will be less work to add new algorithms once the core is working properly.



%this needs to be here somewhere, not in background
\subsection{Development}
The choice of game engine and programming language fell on the decision from the previous project, namely Unity and C\#, as this project's intentions are to directly improve upon this same prototype. Recreating the previous prototype in another game engine would be a lot of unnecessary work, since the plan is to keep everything and just build on top of the existing prototype, and the other game engine would need to be learned, and probably the programming language the game engine uses as well. This does not fit in with the time schedule of this project. In addition, the gained experience with the game engine from the previous project would shorten further development times. In other words, I was already familiar with using Unity and C\# at this point and did not really need to spend more time on learning the engine. This project would continue to work on the same public repository on Github as in the previous project. 
%The chosen game engine in the previous project, and therefore this project also, was Unity, because it has a bigger/more active community which will help when problems or confusion arise. Unity is also considered to be better suited for indie developers. Seeing as I am the only one developing this application, I am more comparable to an indie developer rather than a company.


%The resourses used for learning this in the previous project was a combination of watching youtube videos, reading the documentation, doing tutorials, and experimenting. The main channels used were \href{https://www.youtube.com/channel/UCLO98KHpNx6JwsdnH04l9yQ}{FusedVR} for VR specifics and \href{https://www.youtube.com/user/Brackeys}{Brackeys} for general Unity things. Experimentation proved to be very effective as it gives hands on experience and a sense of how to work with this technology. Youtube videos are great for getting insight into how certain problems can be solved, and to learn what common pitfalls for beginners are and how to avoid these.
%In order to be able to develop this game or application, Unity had to be learned. This was done through the Unity documentation and their own tutorials, as well as through youtube videos, from channels such as \href{https://www.youtube.com/user/Brackeys}{Brackeys}, and experimentation. Experimentation is very effective as it gives hands on experience and a sense of how to work with this technology. Youtube videos are great for getting insight into how certain problems can be solved, and to learn what common pitfalls for beginners are and how to avoid these. 



\subsection{Summary of Plan}
Something which was planned in the previous project, but not achieved was the environment where the user could navigate to different courses and from there to different parts of these courses. My supervisor had suggested a virtual school ground or university ground and have different courses behind different doors or at different locations in this virtual environment. Despite the prototype only having content within one course, this project would attempt to implement this in some form. However, at a low priority. Expanding and improving functionality should be the main focus of this project. 

The ambition of this project is to add at least one sorting algorithm which is actually used in the real world, and add at least some content within another branch of the Algorithms and Data structures course. This will most likely be either tree-traversing algorithms, or demonstrating some data structures. Improving the existing sorting algorithm scene should also always be attempted. In terms of testing it should be striven after having more test subjects than that which was achieved in the previous project, and also with a higher quality in the testing. 


%A plan was needed before the development could begin. My supervisor had envisioned a sort of virtual university where one could navigate some sort of school or university grounds, and teaching different courses in different areas of this environment. My supervisor also had two groups the previous year which had similar projects where they were using VR to teach sorting algorithms. These were based around the user having to physically sort the cubes but in the way the algorithm dictated it. This idea and these projects would be the foundation for the prototype. 

%An idea, and by that I mean an idea of how the game should be, was also needed before development could begin. My supervisor suggested that the game should be made in a way where it could include many different subjects, and be sort of a virtual university or school. He also suggested that I make the over world or hub look like a university or school, but I thought that it would hinder the inspiration of curiosity, because many people associate schools or class rooms with boredom or other uninspiring emotions. The theory behind game design also suggests that the environment should not be distracting, as the focus should be on the task at hand, or the demonstration. 

%In Oculus Home one can design one's own home space with different interactive and decorative items, and one can visit one's friends homes too. The way this is done, is through breaking a glass orb, with a mini-representation of that home inside the orb(which can be seen in figure \ref{fig:oculussphere}), by throwing it at the floor, and your home is transformed into that of your friend's home. This was the inspiration for my game. I wanted the courses to be glass orbs with a model which could represent the course within them. I thought that this might be simple enough to not distract the user, while at the same time inspire some curiosity through the models inside the orbs. Due to time constraints and manpower, this prototype will only include one course; Algorithms and data structures. Within this course, sorting algorithms are the priority and other algorithms would only be implemented if there was time. 

%\subsection{Development}
% As already mentioned in the background, Unity supports several programming languages, but mainly C\# and javascript. The choice landed on C\# as this was the language used in the existing prototype. The reason for choosing C\# in the previous project was because the youtube tutorials was focusing on this language, that it seemed to be the easiest one to find help to problems for, as well as a personal preference. To be able to use any VR-kit without writing hardware specific code, the SteamVR Plugin for Unity would be used. To be able to work anywhere, the version control system Git would be used, and it should be hosted on Github, as a public repository. There was no need to use Unity's collaboration tool/version control system, Unity Collab, as there would only be one developer during the extent of this project.
 
% Hosting the project on GitHub in a public repository will enable other developers to further build upon this project, should it turn out to be a good one. And maybe one day it can live up to it's name; UniVRsity! 
 
 \subsection{Architecture}
 The architecture in the previous project, was focused around the game having to be modular, and easily expanded. To do this, sorting algorithms had to be generalized such that the common functionality would not need to be re-implemented, instead only specifics for the new algorithm. The same went for user actions. They were also generalized such that it would be easy to add new actions. This architecture makes it a lot easier to add new algorithms and actions, but it requires more thought into the initial development. The algorithms was generalized fairly well in during the development, however, actions, not so much. Due to the way the algorithms were made, they were completely isolated from the arrays them selves, which meant that actions could not be generally designed. The result was actions just having a type, an enum describing what action it represents, and some integer values representing the position within the array the action should affect. This in turn meant that what the different types action actually does is up to whichever component is handling the action. The positive with this is that the action types can be reused in other scenes, as they have no actual actions linked to them. However, in case it probably would have been smarter to not have the sorting algorithms be disconnected from the array representation, and therefor the actions separated from them. 
 
 This project does not intend to change the architecture. It should still focus on being modular, as this makes it easier for other developers to extend the it and improve upon it. Having the prototype keep evolving and eventually encompassing a plethora of courses is kind of the idea or hope here.
 %As far as architecture for the prototype goes, it was more or less just a rough idea in the beginning and evolved as the development progressed. Another aspect I thought was important was for the game to easily add new algorithms, and there will therefore be more work to define what is allowed or possible to do, and how to define an algorithm. In other words, there will be more work to get everything working, but there will be less work to add new algorithms once the core is working properly.

\subsection{Testing}
%The testing in the previous project was very rushed and therefore poorly done. The test subjects were just thrown into the testing with little or no knowledge of what they were testing and what they should do. 
% --- From the spez proj: For testing the prototype, I would use a System Usability Scale. The optimal testers would be people who are currently taking the course Algorithms and data structures and has no experience with VR. This test will give an indication of weather or not the prototype is intuitive and feels natural to use. These same test subjects will also be encouraged to give feedback on any part of the prototype to help me understand what could be done better, seen from a perspective of "fresh eyes". 

The testing in this project will be fairly similar to the form of testing performed in the previous project, whose form was briefly touched upon in the Previous Work section.  This time there will be a short explanation before the testing starts about what the game is, and its intentions. It will give the testers some context in the form of what they can expect in terms of genre and setting. After the introduction of the game, the testers will play the game. No one will give guidance to the testers unless they explicitly ask for help. If a tester asks for help, it is a sign that some part of the game is not intuitive or something should be better explained within the game. The testers will be informed of this, to increase the threshold for asking for help. After the testers feel they have done enough, they will be asked to fill out a form. This form will contain a section regarding some background information of the tester, a part with the standard SUS questions for getting a usability score, and some general feedback regarding the game and their experience with it. The targets for this testing will be people who has taken or is taking the Algorithms and data structures course, as well as people who has not taken the course but has some experience and knowledge of programming. The level of VR experience a tester has is not of much importance, though a varied spectrum could be nice. This would open up the possibility to check for a connection between previous experience with VR and their understanding of the prototype. As already mentioned the previous project was only able to perform the testing with five people. This time around, the aim is to at least perform tests with double the amount of people.
%When the coding in Unity started, I started with only the bubble sort algorithm in mind. This was a mistake, as this led to having to redo my design at least two times, and also had to redo the core of the sorting algorithms a couple of times as well. This was a huge loss of time, but I believe the core is now pretty sturdy and allows for easy addition of other sorting algorithms. Another big time loss occurred due to an update in the SteamVR Plugin. The development started when it was in version 1, and in version 2, which was launched at the end of September, they had redone the whole interaction system, which meant the interaction system in my game also had to be redone. It also took some time to figure out how this new interaction system worked.



