%denne delen skal forklare hvordan spillet har blitt implementert og hvordan teorien har blitt utnyttet
\section{Methodology}

This section will present how the prototype was planned, the different choices made in regards to how the development should be done, and also how the testing should be performed. 

\subsection{General Plan}
The plan going into this project was to continue the development of the prototype developed in the previous project. Making improvements and adding new features to it, and then test it again to see if it was actually improved. As far as design goes there will not be any major changes, unless something which forces this occurs. There will however be additions to it, and these additions will try to achieve a similar style. This is to be consistent with how things work, not causing unnecessary confusion in the players. The planning of the expansion of content and making improvements will happen in iterations. Come up with a next step(a general idea, no specifics), figure out how to implement this idea, implement it, then from there figure out where to go next. The next step for each iteration would mostly come from the meetings with the supervisor.  

Coming from the previous project the structure of the prototype was just a single scene. However, the plan for a finished product looked something like that which can be seen in  \autoref{fig:plan}. The question marks represent any number of courses or topics, and the structure is hierarchical. The overworld is at the top of the hierarchy and form there the player can navigate to any course hub. The course hubs are the next level of the hierarchy where the player can either navigate back to the overworld, or to any topic within the course. The topics are the lowest level in the hierarchy, and the player can only navigate back to its course hub from there. This hierarchy will be the guide when adding new content in this project.


\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/Plan.png}
\caption{The idea of how the scenes in the final product should be arranged. The question marks can be any number of boxes.}
\label{fig:plan}
\end{figure}



\subsubsection{Iteration 1}
The goal for the first iteration was to add another topic from the course Algorithms and data structures. The topic chosen was data structures, despite the previous project having some ideas around tree traversing algorithms. The reason for this, was to better represent the content of the course. It is not only about algorithms. Another idea which were considered was to start adding another course like Machine learning. This would imply a scene structure like the one seen in \autoref{fig:plan_potential}. However, this was discarded for the time being, and the structure would instead look like the one presented in \autoref{fig:plan_final}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/potential_further_dev.png}
\caption{How the scenes in the game would be arranged, if the machine learning course was added instead of the data structure topic.}
\label{fig:plan_potential}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/actual_result.png}
\caption{The plan for how the scenes in the game would be arranged, after the first iteration}
\label{fig:plan_final}
\end{figure}

\subsubsection{Iteration 2}
The next iteration after the initial data structure scene was added, was to go back to the sorting algorithm scene and add a better and more commonly used algorithm to the mix. The algorithm chosen was quick sort, as it fits these criteria.

\subsubsection{Iteration 3}
In the third iteration, the idea was to add some form of use case to each of the data structures. The idea behind that idea was to show the player how this data structure could be used in a real life scenario. As the data structures added in the previous iteration was a stack and a queue, and the supervisor teaching visual computations the decision for use case landed on an image region growing algorithm. This algorithm need to keep track of which pixels to explore, which works with both a stack and a queue, but will behave different in how the pattern grows.

\subsubsection{Iteration 4}
Seeing as the overworld, course hubs, and the navigation between them was still not implemented, it was time to do this. This was planned already back in the previous project but not achieved in the duration of it, and it was long overdue to get started on this. It would still be arranged like the figure from iteration 1,  \autoref{fig:plan_final}. My supervisor had an idea of making the overworld look similar to a school ground or university ground. However, due to time constraints, the looks of it was not the priority. The priority was getting the functionality down. Considering that I have no experience in creating 3D models, textures, or other forms of visuals, the results would probably be sub-par and it would cost me a lot of time. 

\subsubsection{Iteration 5}
After the overworld and navigation was added, I wanted to add the merge sort algorithm. Though this required a lot of rework to the sorting scene in the state it was at, at the time. Merge sort is different to the other three sorting algorithms in that it creates new arrays in the process.  

\subsubsection{Iteration 6} \label{sec:It6}
This time I had realized that I had forgotten to improve things which were commented on or discovered during the testing in the previous project. I had been too focused on adding new features and improving stability and architecture, and forgotten probably the most important part; improving the usability. This iteration would therefore consist of making a lot of improvements in terms of usability and thoroughly testing the application to find and squash bugs before the testing started. 

\subsection{Development}
The choice of game engine and programming language fell on the decision from the previous project, namely Unity and C\#, as this project's intentions are to directly improve upon this same prototype. Recreating the previous prototype in another game engine would be a lot of unnecessary work, since the plan is to keep everything and just build on top of the existing prototype, and the other game engine would need to be learned, and probably the programming language the game engine uses as well. This does not fit in with the time schedule of this project. In addition, the gained experience with the game engine from the previous project would shorten further development times. In other words, I was already familiar with using Unity and C\# at this point and did not really need to spend more time on learning the engine. This project would continue to work on the same public repository on Github as in the previous project. 

This project does not intend to alter the architecture of the existing prototype. It should still focus on being modular, as this makes it easier for other developers to extend it and improve upon it. Having the prototype keep evolving and eventually encompassing a plethora of courses is kind of the idea or hope here. However, considering the time constraint, making things work is more important than having a good architecture. At least in the short term scenario. 

\subsubsection{Requirements}
Following is a list of functional requirements for the project, sorted by the scenes. Non-functional requirements were not set, except for keeping the prototype performance efficient.

\subsubsection*{Common to all scenes}
\begin{itemize}
    \item Player - A camera and controller reflecting the physical orientation and position of the player hand his/her hands/controllers. Also has a laser pointer in the right hand for interacting with the world
    \item Show outline on interactive objects when hovering over with the laser pointer
    \item Interact with interactive objects by pressing the trigger button on the controller with the laser pointer while pointing at it
    \item Buttons - Interactive object
    \item Show which buttons are disabled by changing their color, and the color of the outline when hover over
\end{itemize}

\subsubsection*{Over world}
\begin{itemize}
    \item Show available courses as different buttons
    \item Course buttons - Loads the button's course
    \begin{itemize}
        \item Algorithms and Data Structures
    \end{itemize}
\end{itemize}

\subsubsection*{Algorithms and Data Structures}
\textbf{Course hub(entry point):}
\begin{itemize}
    \item Show available topics as buttons
    \item \textbf{Topic buttons} - Loads the button's topic
    \begin{itemize}
        \item Data structures
        \item Sorting algorithms
    \end{itemize}
    \item Back navigation button - Go back to the over world
\end{itemize}

\textbf{Data structures:}
\begin{itemize}
    \item \textbf{Play mode} - Learn how the selected structure works
    \begin{itemize}
        \item Show available structures as buttons
        \item \textbf{Structure buttons} - Go to play mode for selected structure
        \begin{itemize}
            \item Stack
            \item Queue
        \end{itemize}
        \item \textbf{Stack and Queue} - Same play mode
        \begin{itemize}
            \item Show a representation of the data structure
            \item Push/Enqueue button - Animate how the structure handles addition of data
            \item Pop/Dequeue button - Animate how the structure handles removal/retrieval of data
            \item Use case button - Go to use case mode for this structure
            \item Back navigation button - Go back to course hub
            \item Show explanation of each button
            \item Show error message when doing an illegal action containing the error (Overflow/Underflow) and when it occurs
        \end{itemize}
    \end{itemize}
    \item \textbf{Use case mode} - See how the selected structure can be used in a real life scenario
    \begin{itemize}
        \item \textbf{Stack and Queue} - Same use case: Image region growing
        \begin{itemize}
            \item Back navigation button - Go back to play mode for this structure
            \item Show a description of what this use case is when entering the use case mode. Press the button on this panel to hide it and start the algorithm.
            \item Show a black and white image with random pattern. Each pixel is an interactive object.
            \item Pixel(interactive object) - Select (show a border color to indicate that it is selected)
            \item Show a representation of the data structure selected before entering use case mode
            \item Show a representation of the the item from the data structure is currently being read/used ("Next" as it points to the next pixel to check)
            \item Show a representation of the internal state of the algorithm (Pattern so far, visited pixels, which pixel is next, etc...)
            \item Show an explanation of the color coding in the representation of the algorithm
            \item \textbf{Action buttons}
            \begin{itemize}
                \item Push/Enqueue - Animate addition of the selected Pixel to the data structure
                \item Pop/Dequeue - Animate removal of next pixel from the data structure and into the "Next" position. 
                \item Check - Animate the checking(whether it is or is not part of the pattern) of the pixel.
            \end{itemize}
            \item \textbf{Algorithm interaction buttons}
            \begin{itemize}
                \item Demo(toggle button) - Start/stop the demonstration of the algorithm. The demonstration animates how the algorithm works step by step.
                \item Prev - Undo the last step in the algorithm(animate)
                \item Next - Do the next step in the algorithm(animate)
            \end{itemize}
            \item An attempt at doing an action the algorithm does not expect, it will not perform the action and instead hint at the expected action by blinking the required elements and action button a few times. 
            \item Data items popped or dequeued into "Next" will fire a laser at the pixel it represents. To indicate which pixel should be checked next
        \end{itemize}{}
    \end{itemize}
\end{itemize}

\textbf{Sorting Algorithms}
\begin{itemize}
    \item Back navigation button - Go back to course hub
    \item Show available sorting algorithms as buttons
    \item Show the array as a horizontal set of cuboids(array elements) on top of another cuboid(array stand or representation of the memory location). The elements has a height relative to their value: high value means a tall cuboid, and a low value means a short cuboid.  
    \item Both the array and the the elements are interactive
    \item Show a Cube representing the storage (where array elements can be temporarily stored)
    \item Show a representation of the internal state of the algorithm
    \item Show pseudo code for the selected algorithm
    \item \textbf{Sorting algorithm buttons} - Generates a new random array and changes to this algorithm
    \begin{itemize}
        \item Bubble sort
        \item Insertion sort
        \item Quick sort
        \item Merge sort
    \end{itemize}
    \item \textbf{Algorithm interaction buttons}
    \begin{itemize}
        \item Demo(toggle button) - Start/stop demonstrating the algorithm. The demonstration shows the algorithm step by step in the correct order and explains what it is doing.
        \item Prev - Undo the last step in the algorithm(animate)
        \item Next - Do the next step in the algorithm(animate)
        \item New array - Generate a new random array
        \item Restart - Resets the algorithm, and array back to start    
    \end{itemize}
    \item \textbf{Action buttons}
    \begin{itemize}
        \item Compare - Compare the value of two elements
        \item Swap - Swap the values/position of one or two element(s)
        \item Store - Clone one of the elements in the array to the storage
        \item Copy to - Two step action: Copy selected element value into the next selection (limitations: can not copy to storage, use Store instead)
        \item Pivot - Sets the selected element as a pivot
        \item Split - Splits the selected array in two halves
        \item Merge - Start the merge of two arrays
    \end{itemize}
    \item An attempt at doing an action the algorithm does not expect, it will not perform the action and instead hint at the expected action by blinking the required elements and action button a few times. 
    
\end{itemize}

\subsubsection{Implementation}
This part will talk a bit about how the major parts in the game was coded, how they work, and how they interact with each other.

\subsection{Evaluation}
The evaluation in this project will be fairly similar to the form of evaluation performed in the previous project, whose form was briefly touched upon in the Previous Work section.  This time there will be a short explanation before the evaluation starts about what the game is, and its intentions. It will give the participants some context in the form of what they can expect in terms of genre and setting. After the introduction of the game, they will play the game. No one will give guidance to them unless they explicitly ask for help. If a participant asks for help, it is a sign that some part of the game is not intuitive or something should be better explained within the game. The participants will be informed of this, to increase the threshold for asking for help. After the participants feel they have done enough, they will be asked to fill out a form. This form will contain a section regarding some background information of the participant, a part with the standard SUS questions for getting a usability score, and some general feedback regarding the game and their experience with it. The targets for this evaluation will be people who has taken or is taking the Algorithms and data structures course, as well as people who has not taken the course but has some experience and knowledge of programming. The level of VR experience a participant has is not of much importance, though a varied spectrum could be nice. This would open up the possibility to check for a connection between previous experience with VR and their understanding of the prototype. As already mentioned the previous project was only able to perform the testing with five people. This time around, the aim is to at least perform tests with double the amount of people.
